/*  Copyright (c) 2008 Konrad-Zuse-Zentrum fuer Informationstechnik Berlin,
 Barcelona Supercomputing Center - Centro Nacional de Supercomputacion
 and Consiglio Nazionale delle Ricerche.

 This file is part of XtreemFS. XtreemFS is part of XtreemOS, a Linux-based
 Grid Operating System, see <http://www.xtreemos.eu> for more details.
 The XtreemOS project has been developed with the financial support of the
 European Commission's IST program under contract #FP6-033576.

 XtreemFS is free software: you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
 Software Foundation, either version 2 of the License, or (at your option)
 any later version.

 XtreemFS is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with XtreemFS. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * AUTHORS: Jan Stender (ZIB), Björn Kolbeck (ZIB), Jesús Malo (BSC)
 *          Eugenio Cesario (CNR)
 */

package org.xtreemfs.common;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.xtreemfs.common.clients.HttpErrorException;
import org.xtreemfs.common.clients.RPCClient;
import org.xtreemfs.common.clients.RPCResponse;
import org.xtreemfs.common.clients.dir.DIRClient;
import org.xtreemfs.common.config.ServiceConfig;
import org.xtreemfs.common.logging.Logging;
import org.xtreemfs.common.util.NetUtils;
import org.xtreemfs.common.util.OutputUtils;
import org.xtreemfs.common.uuids.ServiceUUID;
import org.xtreemfs.foundation.LifeCycleThread;
import org.xtreemfs.foundation.json.JSONException;

/**
 * A thread that regularly sends a heartbeat signal with fresh service data to
 * the Directory Service.
 */
public class HeartbeatThread extends LifeCycleThread {
    
    /**
     * An interface that generates service data to be sent to the Directory
     * Service. Each time a heartbeat signal is sent, new service data will be
     * generated by means of invoking <tt>getServiceData()</tt>.
     */
    public interface ServiceDataGenerator {
        public Map<String, Map<String, Object>> getServiceData();
    }
    
    private static final long    UPDATE_INTERVAL = 60 * 1000; // 60s
                                                              
    private ServiceUUID          uuid;
    
    private ServiceDataGenerator serviceDataGen;
    
    private DIRClient            client;
    
    private String               authString;
    
    private volatile boolean     quit;
    
    private final ServiceConfig  config;
    
    public HeartbeatThread(String name, DIRClient client, ServiceUUID uuid,
        ServiceDataGenerator serviceDataGen, String authString, ServiceConfig config) {
        
        super(name);
        
        this.client = client;
        this.uuid = uuid;
        this.serviceDataGen = serviceDataGen;
        this.authString = authString;
        this.config = config;
    }
    
    public void shutdown() {
        this.quit = true;
        this.interrupt();
        try {
            if (client.getSpeedy().isAlive()) {
                RPCResponse<String> r = client.deregisterEntity(uuid.toString(), authString);
                r.waitForResponse(2000);
                Logging.logMessage(Logging.LEVEL_INFO, this, uuid + " dergistered");
            }
        } catch (Exception ex) {
            Logging.logMessage(Logging.LEVEL_ERROR, this, "cannot deregister at DIR: " + ex);
        }
    }
    
    public void run() {
        
        List<RPCResponse> responses = new LinkedList<RPCResponse>();
        Map<String, Long> verMap = new HashMap<String, Long>();
        
        // initially, ...
        try {
            
            // ... for each UUID, ...
            for (Entry<String, Map<String, Object>> mapEntry : serviceDataGen.getServiceData()
                    .entrySet()) {
                
                // ... remove old DS entry if necessary
                if (!"volume".equals(mapEntry.getValue().get("type"))) {
                    RPCResponse r = client.deregisterEntity(mapEntry.getKey(), authString);
                    r.waitForResponse();
                    responses.add(r);
                }
                
                // ... register the entity
                registerEntity(mapEntry.getKey(), mapEntry.getValue(), verMap, authString,
                    responses);
                if (Logging.isDebug())
                    Logging.logMessage(Logging.LEVEL_DEBUG, this, uuid
                        + " successfully registered at Directory Service");
            }
            
            // ... register the address mapping for the service
            
            List<Map<String, Object>> endpoints = null;
            
            //check if a listen.address is set
            if (config.getAddress() == null) {
                endpoints = NetUtils.getReachableEndpoints(uuid.getAddress()
                    .getPort(), uuid.getProtocol());
            } else {
                //if it is set, we should use that for UUID mapping!
                endpoints = new ArrayList(1);
                
                // remove the leading '/' if necessary
                String dottedQuad = config.getAddress().toString();
                if(dottedQuad.startsWith("/"))
                    dottedQuad = dottedQuad.substring(1);
                
                Map<String,Object> m = RPCClient.generateMap("address", dottedQuad,
                        "port", uuid.getAddress().getPort(), "protocol", uuid.getProtocol(), 
                        "ttl", 3600, "match_network", "*");
                endpoints.add(m);
            }
            
            // fetch the latest address mapping version from the Directory
            // Serivce
            long version = 0;
            RPCResponse r2 = client.getAddressMapping(uuid.toString(), authString);
            try {
                Map<String, List<Object>> result = (Map<String, List<Object>>) r2.get();
                
                // retrieve the version number from the address mapping
                Collection<Entry<String, List<Object>>> entries = result.entrySet();
                if (entries.size() != 0) {
                    List<Object> valueList = entries.iterator().next().getValue();
                    version = (Long) valueList.get(0);
                }
            } finally {
                responses.add(r2);
            }
            
            // register/update the current address mapping
            RPCResponse r3 = client.registerAddressMapping(uuid.toString(), endpoints, version,
                authString);
            try {
                r3.waitForResponse();
            } finally {
                responses.add(r3);
            }
            
        } catch (Exception ex) {
            Logging.logMessage(Logging.LEVEL_ERROR, this,
                "an error occurred while initially contacting the Directory Service: "
                    + OutputUtils.stackTraceToString(ex));
            notifyCrashed(ex);
        } finally {
            for (RPCResponse resp : responses)
                resp.freeBuffers();
        }
        
        notifyStarted();
        
        // periodically, ...
        while (!quit) {
            
            responses.clear();
            
            try {
                
                // ... for each UUID, ...
                for (Entry<String, Map<String, Object>> mapEntry : serviceDataGen.getServiceData()
                        .entrySet()) {
                    
                    // ... update the Directory Service entry for the service
                    registerEntity(mapEntry.getKey(), mapEntry.getValue(), verMap, authString,
                        responses);
                    if (Logging.isDebug())
                        Logging.logMessage(Logging.LEVEL_DEBUG, this, uuid
                            + " successfully updated at Directory Service");
                }
                
            } catch (IOException ex) {
                Logging.logMessage(Logging.LEVEL_ERROR, this, ex);
            } catch (JSONException ex) {
                Logging.logMessage(Logging.LEVEL_ERROR, this, ex);
            } catch (InterruptedException ex) {
                quit = true;
                break;
            } finally {
                for (RPCResponse resp : responses)
                    resp.freeBuffers();
            }
            
            if (quit)
                break;
            
            try {
                Thread.sleep(UPDATE_INTERVAL);
            } catch (InterruptedException e) {
                // ignore
            }
        }
        
        notifyStopped();
    }
    
    private void registerEntity(String uuid, Map<String, Object> data,
        Map<String, Long> versionMap, String authString, List<RPCResponse> responses)
        throws HttpErrorException, InterruptedException, IOException, JSONException {
        
        Long ver = versionMap.get(uuid);
        if (ver == null)
            ver = 0L;
        
        // in case the data object refers to a volume, check whether a volume
        // with the same name exists already
        if ("volume".equals(data.get("type"))) {
            
            RPCResponse<Map<String, Map<String, Object>>> response = client.getEntities(RPCClient
                    .generateMap("name", data.get("name")),
                RPCClient.generateStringList("version"), authString);
            
            try {
                Map<String, Map<String, Object>> entities = response.get();
                
                if (!entities.isEmpty()) {
                    String id = entities.keySet().iterator().next();
                    
                    if (id != null && !id.equals(uuid)) {
                        Logging.logMessage(Logging.LEVEL_WARN, this,
                            "WARNING: could not register volume '" + data.get("name")
                                + "', as it has already been registered with a different UUID: "
                                + id + "!");
                        return;
                        
                    } else
                        ver = Long.parseLong((String) entities.get(id).get("version"));
                }
            } finally {
                responses.add(response);
            }
        }
        
        RPCResponse<Long> response = client.registerEntity(uuid, data, ver, authString);
        try {
            versionMap.put(uuid, response.get());
        } catch (HttpErrorException exc) {
            
            // if the version number was outdated for some reason, fetch the
            // latest version of the entity
            if (exc.getStatusCode() == 420) {
                
                RPCResponse<Map<String, Map<String, Object>>> r = client.getEntities(RPCClient
                        .generateMap("uuid", uuid), RPCClient.generateStringList("version"),
                    authString);
                try {
                    Map<String, Map<String, Object>> result = r.get();
                    
                    // retrieve the version number
                    Collection<Entry<String, Map<String, Object>>> entries = result.entrySet();
                    if (entries.size() != 0) {
                        Map<String, Object> valueMap = entries.iterator().next().getValue();
                        versionMap.put(uuid, Long.valueOf((String) valueMap.get("version")));
                    }
                    
                } finally {
                    responses.add(r);
                }
            }
            
            throw exc;
        } finally {
            responses.add(response);
        }
    }
}
