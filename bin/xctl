#!/usr/bin/env python

import os.path, shutil, subprocess, signal, sys, traceback, unittest
from time import sleep


# Constants
DEBUG_LEVEL_DEFAULT = 0

# Paths
CLIENT_MOUNT_POINT_DIR_PATH_DEFAULT = "mnt"
DIR_DATABASE_DIR_PATH_DEFAULT = os.path.join( "data", "dir" )
DIR_DATABASE_LOG_PATH_DEFAULT = os.path.join( "data", "dir" )
MRC_DATABASE_DIR_PATH_DEFAULT = os.path.join( "data", "mrc" )
MRC_DATABASE_LOG_PATH_DEFAULT = os.path.join( "data", "mrc" )
MY_DIR_PATH = os.path.dirname( os.path.abspath( sys.modules[__name__].__file__ ) )
OSD_DATABASE_DIR_PATH_DEFAULT = os.path.join( "data", "osd" )
OSD_DATABASE_LOG_PATH_DEFAULT = os.path.join( "data", "osd" )
SERVER_CONFIG_DIR_PATH_DEFAULT = "config"
SERVER_LOG_DIR_PATH_DEFAULT = "log"
SERVER_RUN_DIR_PATH_DEFAULT = "run"

# Ports
DIR_HTTP_PORT_DEFAULT = 30638
DIR_ONCRPC_PORT_DEFAULT = 32638
MRC_HTTP_PORT_DEFAULT = 30636 
MRC_ONCRPC_PORT_DEFAULT = 32636
OSD_HTTP_PORT_DEFAULT = 30640
OSD_ONCRPC_PORT_DEFAULT = 32640

# URIs
DIR_URI_DEFAULT = "oncrpc://localhost:%u/" % DIR_ONCRPC_PORT_DEFAULT
MRC_URI_DEFAULT = "oncrpc://localhost:%u/" % MRC_ONCRPC_PORT_DEFAULT
OSD_URI_DEFAULT = "oncrpc://localhost:%u/" % OSD_ONCRPC_PORT_DEFAULT

# Misc
STRIPE_SIZE_DEFAULT = 128
STRIPING_POLICY_TYPE_DEFAULT = "RAID0"


      

class Autotest:
    def __init__( self, osd_count=1, server_uri="oncrpc://localhost" ):        
        self.__osd_count = osd_count
        self.__server_uri = server_uri

    def clean( 
               self,
               client_log_dir_path=CLIENT_LOG_DIR_PATH_DEFAULT,
               client_mount_dir_path=CLIENT_MOUNT_POINT_DIR_PATH_DEFAULT,
               server_config_dir_path=SERVER_CONFIG_DIR_PATH_DEFAULT,
               server_log_dir_path=SERVER_LOG_DIR_PATH_DEFAULT,               
             ):
        
        for dir_path in ( 
                          client_log_dir_path, client_mount_dir_path,
                          server_config_dir_path, server_log_dir_path
                         ):
            try: shutil.rmtree( dir_path )
            except: pass
    
    def start_clients( 
                       self,
                       log_dir_path=CLIENT_LOG_DIR_PATH_DEFAULT,
                       mount_point_dir_path=CLIENT_MOUNT_POINT_DIR_PATH_DEFAULT,                        
                     ):
        volumes = []        

        try: os.mkdir( log_dir_path )
        except: pass
        
        try: os.mkdir( CLIENT_MOUNT_POINT_DIR_PATH_DEFAULT )
        except: pass                       
                
        for osd_i in xrange( self.__osd_count ):
            volume_name = "test_" + str( osd_i )
            volume = Volume( name=volume_name, mount_point_dir_path=os.path.join( mount_point_dir_path, volume_name ) )
            volume.create( mrc_uri=self.__server_uri )
            volume.mount( dir_uri=self.__server_uri, log_file_path=os.path.join( log_dir_path, "client"+str( osd_i )+".log" ) )
            volumes.append( volume )
            
        return volumes                            
    
    def start_servers( 
                       self,
                       config_dir_path=SERVER_CONFIG_DIR_PATH_DEFAULT,
                       log_dir_path=SERVER_LOG_DIR_PATH_DEFAULT,
                      ):
        servers = []        
        
        for subdir_name in ( config_dir_path, "data", log_dir_path ):
            try: os.mkdir( subdir_name )
            except: pass                
            
        dir = DIR( config_file_path=os.path.join( SERVER_CONFIG_DIR_PATH_DEFAULT, "dir.config" ) )
        dir.configure( uuid="test-env-DIR" )                                
        dir.start()
        servers.append( dir )
        
        mrc = MRC( config_file_path=os.path.join( SERVER_CONFIG_DIR_PATH_DEFAULT, "mrc.config" ) )
        mrc.configure( uuid="test-env-MRC" )
        mrc.start()            
        servers.append( mrc )
                        
        for osd_i in xrange( self.__osd_count ):
            osd = OSD( config_file_path=os.path.join( SERVER_CONFIG_DIR_PATH_DEFAULT, "osd"+str( osd_i)+".config" ) )
            osd.configure( http_port=OSD_HTTP_PORT_DEFAULT+osd_i,
                           oncrpc_port=OSD_ONCRPC_PORT_DEFAULT+osd_i,
                           uuid="test-env-OSD" + str( osd_i ) )             
            osd.start()
            servers.append( osd )
            
        return servers
                            
    def run( self ):
        volumes = self.start_clients()
        servers = self.start_servers()
        
        ret = 0
        for volume in volumes:
            ret |= volume.test()
        
        for server in servers:
            try: server.stop()
            except: traceback.print_exc()
            
        for volume in volumes:
            try: volume.unmount()
            except: traceback.print_exc()
    
        return ret
    
    def stop_clients( self ):
        for osd_i in xrange( self.__osd_count ):
            volume_name = "test_" + str( osd_i )
            volume = Volume( name=volume_name, mount_point_dir_path=os.path.join( CLIENT_MOUNT_POINT_DIR_PATH_DEFAULT, volume_name ) )
            volume.unmount()
    
    def stop_servers( self ):
        raise NotImplementedError


class Server:
    def __init__( self, config_file_path ):
        self.__config_file_path = config_file_path

    def _get_ssl_config( 
                         self, 
                         enable_grid_ssl=False, 
                         enable_ssl=False, 
                         pkcs12_file_path=None, 
                         pkcs12_passphrase=None, 
                         trusted_certs_jks_file_path=None, 
                         trusted_certs_jks_passphrase=None 
                       ):  
                 
        if enable_ssl:            
            if enable_grid_ssl:
                gridsslcfg = "ssl.grid_ssl = true\n"
            else:
                gridsslcfg = "ssl.grid_ssl = false\n"
                            
            return """\
ssl.enabled = true
ssl.service_creds = %(pkcs12_file_path)s
ssl.service_creds.pw = %(pkcs12_passphrase)s
ssl.service_creds.container = PKCS12
ssl.trusted_certs = %(trusted_certs_jks_file_path)s
ssl.trusted_certs.pw = %(trusted_certs_jks_passphrase)s
ssl.trusted_certs.container = JKS        
""" % locals() + gridsslcfg
        else:        
            return """\
ssl.enabled = false        
"""                    

    def get_config_file_path( self ):
        return self.__config_file_path

    def __get_config_property( self, key ):
        for line in open( self.__config_file_path ).readlines():
            test_key, value = line.split( "=" )
            test_key = test_key.strip()
            if test_key == key:
                return value.strip()
            
        raise ValueError, key + " = not found in " + self.__config_file_path

    def __get_run_file_path( run_dir_path ):
        return os.path.join( run_dir_path, self.get_uuid() + ".run" )        

    def get_http_port( self ):
        return int( self.__get_config_property( "http_port" ) )
        
    def get_uuid( self ):
        return self.__get_config_property( "uuid" )

    def is_running( self, run_dir_path=SERVER_RUN_DIR_PATH_DEFAULT ):
        run_file_path = self.__get_run_file_path( run_dir_path )
        if os.path.exists( run_file_path ):
            pid = int( open( run_file_path ).read().strip() )
            try:
                procid, exitvalue = os.waitpid( pid, os.WNOHANG )
                return procid == 0 and exitvalue == 0
            except OSError:
                return False            
        else:
            return False

    def save_status_page( self, to_file_path ):
        http_port = self.get_http_port()
        os.system( "wget -O %(to_file_path)s http://localhost:%(http_port)u" % locals() )

    def start( 
               self, 
               log_dir_path=SERVER_LOG_DIR_PATH_DEFAULT, 
               run_dir_path=SERVER_RUN_DIR_PATH_DEFAULT 
             ):
                
        try: os.mkdir( log_dir_path )
        except: pass
        log_file_path = os.path.join( log_dir_path, self.get_uuid() + ".log" )
        
        try: os.mkdir( run_dir_path )
        except: pass
        run_file_path = self.__get_run_file_path( run_dir_path )
                
        args = [os.path.join( os.environ["JAVA_HOME"], "bin", "java" )] 
        args.append( "-ea" ) # Enable assertions
        args.extend( ( "-cp", "" + ( sys.platform.startswith( "win" ) and ";".join( CLASSPATH ) or ":".join( CLASSPATH ) ) + "", ) )
        args.append( "org.xtreemfs." + self.__class__.__name__.lower() + "." + self.__class__.__name__.upper() )
        args.append( self.get_config_file_path() )        
        stderr = stdout = open( log_file_path, "a" )
        
        p = subprocess.Popen( args, shell=True, stdout=stdout, stderr=stderr )
        
        sleep( 1.0 )
        
        open( run_file_path, "w+" ).write( str( p.pid ) )
                                
        if not self.is_running( run_dir_path ):
            raise RuntimeError, self.get_uuid() + " failed to start"
        
    def stop( self, run_dir_path=SERVER_RUN_DIR_PATH_DEFAULT ):
        run_file_path = self.__get_run_file_path( run_dir_path )           
        if os.path.exists( run_file_path ):
            pid = int( open( run_file_path ).read().strip() )
            if sys.platform.startswith( "win" ):
                call( "TASKKILL /PID %(pid)u /F /T" % locals() )
            else:
                try: os.kill( pid, signal.SIGTERM )
                except: traceback.print_exc()
                                   
                sleep( 1 )
                
                try:
                    if os.waitpid( pid,os.WNOHANG )[0] == 0:
                        os.kill( pid, signal.SIGKILL )
                except:
                    pass
                
            os.unlink( run_file_path )        
        

class DIR(Server):
    def configure( 
                   self,
                   uuid,
                   database_dir_path=DIR_DATABASE_DIR_PATH_DEFAULT, 
                   database_log_dir_path=DIR_DATABASE_LOG_PATH_DEFAULT, 
                   debug_level=DEBUG_LEVEL_DEFAULT, 
                   http_port=DIR_HTTP_PORT_DEFAULT,
                   oncrpc_port=DIR_ONCRPC_PORT_DEFAULT
                   **kwds 
                 ):

        try: os.mkdir( database_dir_path )
        except: pass
        
        try: os.mkdir( database_log_dir_path )
        except: pass 
                    
        open( self.get_config_file_path(),"""\
uuid = %(uuid)s
babudb.debug.level = %(debug_level)s
babudb.logDir = %(database_log_dir_path)s
babudb.baseDir = %(database_dir_path)s
babudb.sync = FSYNC
babudb.worker.maxQueueLength = 250
babudb.worker.numThreads = 0
babudb.maxLogfileSize = 16777216
babudb.checkInterval = 300
babudb.pseudoSyncWait = 200
debug.level = %(debug_level)s
listen.port = %(oncrpc_port)u
http_port = %(http_port)u
database.dir = %(database_dir_path)s
authentication_provider = org.xtreemfs.common.auth.NullAuthProvider
""" % locals() + self._get_ssl_config( **kwds ) )
         

class MRC(Server):    
    def configure( 
                   self,
                   uuid,
                   database_dir_path=MRC_DATABASE_DIR_PATH_DEFAULT, 
                   database_log_dir_path=MRC_DATABASE_LOG_PATH_DEFAULT, 
                   debug_level=DEBUG_LEVEL_DEFAULT,
                   dir_uri=DIR_URI_DEFAULT, 
                   http_port=MRC_HTTP_PORT_DEFAULT,
                   oncrpc_port=MRC_ONCRPC_PORT_DEFAULT
                   **kwds 
                  ):        
        
        try: os.mkdir( database_dir_path )
        except: pass
        
        try: os.mkdir( database_log_dir_path )
        except: pass 
        
        dir_service_host = "localhost"
        dir_service_port = DIR_ONCRPC_PORT_DEFAULT
                        
        open( self.get_config_file_path(), "w+" ).write( """\
uuid = %(uuid)s
debug.level = %(debug_level)s
listen.port = %(oncrpc_port)u
http_port = %(http_port)u 
dir_service.host = %(dir_service_host)s
dir_service.port = %(dir_service_port)u
babudb.debug.level = %(debug_level)s
babudb.logDir = %(database_log_dir_path)s
babudb.baseDir = %(database_dir_path)s
babudb.sync = ASYNC
babudb.worker.maxQueueLength = 250
babudb.worker.numThreads = 0
babudb.maxLogfileSize = 16777216
babudb.checkInterval = 300
babudb.pseudoSyncWait = 0
osd_check_interval = 300
no_atime = true
no_fsync = true
local_clock_renewal = 50
remote_time_sync = 60000
database.checkpoint.interval = 1800000
database.checkpoint.idle_interval = 1000
database.checkpoint.logfile_size = 16384
authentication_provider = org.xtreemfs.common.auth.NullAuthProvider
capability_secret = testsecret
""" % locals() )       


class OSD(Server):        
    def configure( 
                   self,
                   uuid,
                   database_dir_path=OSD_DATABASE_DIR_PATH_DEFAULT, 
                   database_log_dir_path=OSD_DATABASE_LOG_PATH_DEFAULT, 
                   debug_level=DEBUG_LEVEL_DEFAULT,
                   dir_uri=DIR_URI_DEFAULT, 
                   http_port=OSD_HTTP_PORT_DEFAULT,
                   object_dir_path=None,
                   oncrpc_port=OSD_ONCRPC_PORT_DEFAULT,
                   **kwds 
                 ):               

        try: os.mkdir( database_dir_path )
        except: pass
        
        try: os.mkdir( database_log_dir_path )
        except: pass 
        
        if object_dir_path is None:     
            object_dir_path = os.path.join( "data", self.get_uuid() )

        dir_service_host = "localhost"
        dir_service_port = DIR_ONCRPC_PORT_DEFAULT            
                            
        open( self.get_config_file_path(), "w+" )( """\
uuid = %(uuid)s
debug.level = %(debug_level)s
listen.port = %(oncrpc_port)u
http_port = %(http_port)u
dir_service.host = %(dir_service_host)s
dir_service.port = %(dir_service_port)u
object_dir=%(object_dir_path)s
local_clock_renewal = 50
remote_time_sync = 60000
report_free_space = true
checksums.enabled = false
capability_secret = testsecret
""" % locals() + self._get_ssl_config( **kwds ) )


class Volume:
    def __init__( self, name, mount_point_dir_path=CLIENT_MOUNT_POINT_DIR_PATH_DEFAULT ):
        self.__mount_point_dir_path = mount_point_dir_path
        self.__name = name        
    
    def create( 
                self, 
                debug_level=DEBUG_LEVEL_DEFAULT,
                mrc_uri=MRC_URI_DEFAULT,
              ):
        
        mkfs_xtreemfs_file_path = os.path.abspath( MY_DIR_PATH, "mkfs.xtreemfs" )
        if not os.path.exists( mkfs_xtreemfs_file_path ):
            mkfs_xtreemfs_file_path = "mkfs.xtreemfs" # Assume it's in the global path
            
        mkfs_xtreemfs_args = [mkfs_xtreemfs_file_path]
        mkfs_xtreemfs_args.extend( ( "-d", str( debug_level ) ) )
        if enable_ssl: mkfs_xtreemfs_args.extend( CLIENT_SSL_ARGS )                
        mkfs_xtreemfs_args.extend( ( "-p", str( STRIPING_POLICY_TYPE_DEFAULT ) ) )
        mkfs_xtreemfs_args.extend( ( "-s", str( STRIPE_SIZE_DEFAULT ) ) )
#        if not repl_on_close:
#            mkfs_xtreemfs_args.extend( ( "-w", str( osdnum + 1 ) ) ) # Stripe width
#        else:
#            mkfs_xtreemfs_args.extend( ( "-w", "1" ) ) # Stripe width
          
        if not mrc_uri.endswith( "/" ):
            mrc_uri += "/"          
        mkfs_xtreemfs_args.append( mrc_uri + self.__name )
                                            
        subprocess.call( mkfs_xtreemfs_args, shell=True )
    
    def mount( 
               self,
               debug_level=DEBUG_LEVEL_DEFAULT,
               dir_uri=DIR_URI_DEFAULT,
               direct_io=False,
               log_file_path=None,
               metadata_cache=False,            
#               replicate_on_close=False,
               write_back_cache=False
              ):

        if not os.path.exists( self.__mount_point_dir_path ):
            os.mkdir( self.__mount_point_dir_path )        
        
        mount_xtreemfs_file_path = os.path.abspath( MY_DIR_PATH, "mount.xtreemfs" )
        if not os.path.exists( mount_xtreemfs_file_path ):
            mount_xtreemfs_file_path = "mount.xtreemfs" # Assume it's in the global path
 
        mount_xtreemfs_args = [mount_xtreemfs_file_path]
        mount_xtreemfs_args.extend( ( "-d", str( debug_level ) ) )                
        mount_xtreemfs_args.append( "-f" ) # So we can redirect stdout and stderr                
        # if enable_ssl: mount_xtreemfs_args.extend( CLIENT_SSL_ARGS )        
        if direct_io: mount_xtreemfs_args.extend( ( "-o", "direct_io" ) )
        if metadata_cache: mount_xtreemfs_args.append( "--metadata-cache" )
        if write_back_cache: mount_xtreemfs_args.append( "--write-back-cache" )        
        
        mount_xtreemfs_args.append( dir_uri + self.__name )                
        mount_xtreemfs_args.append( self.__mount_point_dir_path )

        if log_file_path is not None:                   
            stderr = stdout = open( log_file_path, "a" )
        else:           
            stderr = sys.stderr
            stdout = sys.stdout
        
        subprocess.Popen( mount_xtreemfs_args, shell=True, stdout=stdout, stderr=stderr )
        
#        if replicate_on_close:
#            sleep(2)
#            repl_attr_cmd = "/usr/bin/setfattr -n xtreemfs.repl_factor -v " + str( osdnum + 1 ) + " " + mount_point_dir_path
#            repl_attr2_cmd = "/usr/bin/setfattr -n xtreemfs.rsel_policy -v 3000 " + mount_point_dir_path
#            subprocess.call( repl_attr_cmd, shell=True )
#            subprocess.call( repl_attr2_cmd, shell=True )

    def test( 
              self, 
              test_module_names=None,
              verbose=False
            ):

        tests_dir_path = os.path.abspath( os.path.join( MY_DIR_PATH, "..", "tests" ) )
        if not os.path.exists( tests_dir_path ):
            raise RuntimeError, "xtreemfs/tests directory does not exist!"

        if verbose:
            stdout = sys.stdout
            stderr = sys.stderr
        else:
            stdout = subprocess.PIPE
            stderr = subprocess.STDOUT        

        try:
            sys.path.append( tests_dir_path )
            test_suite_factories = {}
            if test_module_names is None:
                test_module_names = [os.path.splitext( file_name )[0] for file_name in os.listdir( tests_dir_path ) if file_name.endswith( ".py" )]
                
            for test_module_name in test_module_names:
                # print "Trying to import test", test_module_name
                try:
                    test_module = __import__( test_module_name )
                except ImportError:
                    print "Could not import", test_module_name, "from tests"
                    traceback.print_exc()
                    continue
    
                try: 
                    test_suite_factories[test_module_name] = getattr( test_module, "createTestSuite" )
                except AttributeError:
                    print "Test module", test_module_name, "does not have a createTestSuite global function"                        
                            
            test_module_names = test_suite_factories.keys()
            test_module_names.sort()
            for test_module_name in test_module_names:
                test_suite_factory = test_suite_factories[test_module_name]
                for mount_point_dir_name in os.listdir( self.__mount_point_dir_path ):
                    test_suite = test_suite_factory( direct_io=( not "nondirect" in mount_point_dir_name ), stdout=stdout, stderr=stderr )                
                    if test_suite is not None:            
                        mount_point_dir_path = os.path.join( mnt_dir_path, mount_point_dir_name )
                        print "Running", test_module_name, "in", mount_point_dir_path
                        test_run_dir_path = os.path.join( mount_point_dir_path, test_module_name )
                        try: os.mkdir( test_run_dir_path )
                        except: pass                                         
                        os.chdir( test_run_dir_path )
                        unittest.TextTestRunner( verbosity=( verbose and 2 or 1 ) ).run( test_suite )
                        os.chdir( mount_point_dir_path )
                        try: shutil.rmtree( test_run_dir_path )
                        except: traceback.print_exc()
        
            os.chdir( original_cwd )
            return 0
        except KeyboardInterrupt:
            os.chdir( original_cwd )
            return 1
        except:
            traceback.print_exc()
            os.chdir( original_cwd )
            return 1
        
    def unmount( self ):
        for mounts_line in open( "/proc/mounts" ).readlines():
           mounts_line_parts = mounts_line.split()
           test_device = mounts_line_parts[0]
           test_mount_point_dir_path = mounts_line_parts[1]
           if test_device == "xtreemfs" and test_mount_point_dir_path.startswith( self.__mount_point_dir_path ):
               subprocess.call( " ".join( ["fusermount", "-u", self.__mount_point_dir_path] ), shell=True )        
                       
        
if __name__ == "__main__":
    from optparse import OptionParser
    option_parser = OptionParser( "usage: %prog [options] [oncrpc://]<server_host>[:server_port]" )
    
    option_parser.add_option( "--autotest", action="store_true" )
    option_parser.add_option( "--autotest-osd-count", action="store", dest="autotest_osd_count", type="int" )
    option_parser.add_optoin( "--clean-autotest", action="store_true", dest="clean_autotest" )    
    option_parser.add_option( "--start-autotest-clients", action="store_true", dest="start_autotest_clients" )
    option_parser.add_option( "--start-autotest-servers", action="store_true", dest="start_autotest_servers" )
    option_parser.add_option( "--stop-autotest-clients", action="store_true", dest="stop_autotest_clients" )
    option_parser.add_option( "--stop-autotest-servers", action="store_true", dest="stop_autotest_servers" )
    
    options, positional_args = option_parser.parse_args()
    
    if len( positional_args ) > 1:
        server_uri = positional_args[0]
        if not "://" in server_uri:
            server_uri = "oncrpc://" + server_uri        
    else:
        server_uri = "oncrpc://localhost"

    autotest_options = { 
                         "osd_count": options.autotest_osd_count,
                         "server_uri": options.server_uri 
                        }

    if options.autotest:
        sys.exit( Autotest( **autotest_options ).run() )
    elif options.clean_autotest:
        Autotest( **autotest_options ).clean()
    elif options.start_autotest_clients:
        Autotest( **autotest_options ).start_clients()
    elif options.start_autotest_servers:
        Autotest( **autotest_options ).start_servers()
    elif options.stop_autotest_clients:
        Autotest( **autotest_options  ).stop_clients()
    elif options.stop_autotest_servers:
        Autotest( **autotest_options  ).stop_servers()
