#!/usr/bin/env python

import os.path, shutil, subprocess, signal, sys, traceback, unittest
from optparse import OptionParser
from time import sleep


# Constants
DEBUG_ME = True
CLIENT_DEBUG_LEVEL_DEFAULT = "ERR"
SERVER_DEBUG_LEVEL_DEFAULT = "6"
SERVER_STOP_TRIES = 3

# Paths
MY_DIR_PATH = os.path.dirname( os.path.abspath( sys.modules[__name__].__file__ ) )
SERVER_RUN_DIR_PATH_DEFAULT = "run"

# Ports
DIR_HTTP_PORT_DEFAULT = 30638
DIR_ONCRPC_PORT_DEFAULT = 32638
MRC_HTTP_PORT_DEFAULT = 30636 
MRC_ONCRPC_PORT_DEFAULT = 32636
OSD_HTTP_PORT_DEFAULT = 30640
OSD_ONCRPC_PORT_DEFAULT = 32640

# URIs
DIR_URI_DEFAULT = "oncrpc://localhost:%u/" % DIR_ONCRPC_PORT_DEFAULT
MRC_URI_DEFAULT = "oncrpc://localhost:%u/" % MRC_ONCRPC_PORT_DEFAULT
OSD_URI_DEFAULT = "oncrpc://localhost:%u/" % OSD_ONCRPC_PORT_DEFAULT

# Misc
STRIPE_SIZE_DEFAULT = 128
STRIPING_POLICY_TYPE_DEFAULT = "RAID0"
      

class Autotest:
    def __init__( 
                  self, 
                  osd_count=3, 
                  server_uri="oncrpc://localhost" 
                 ):
        
        self.__osd_count = osd_count
        self.__server_uri = server_uri

    def clean( self, ):        
        for dir_name in ( "config", "data", "log", "mnt" ):  
            try: shutil.rmtree( dir_name )
            except: pass                  

    def __get_servers( self ):
        dir = DIR( config_file_path=os.path.join( "config", "dir.config" ) )
        mrc = MRC( config_file_path=os.path.join( "config", "mrc.config" ) )
        osds = [OSD( config_file_path=os.path.join( "config", "osd"+str( osd_i )+".config" ) ) for osd_i in xrange( self.__osd_count )]
        return dir, mrc, osds
                             
    def __get_volumes( self ):
        volumes = []
        for osd_i in xrange( self.__osd_count ):
            volume_name = "test_" + str( osd_i )
            for direct_io in ( False, True ):
                mount_point_dir_path = os.path.join( "mnt", volume_name )
                if not direct_io:
                    mount_point_dir_path += "_nondirect"
                volume = Volume( name=volume_name, mount_point_dir_path=mount_point_dir_path )
                volumes.append( volume )
        return volumes
    
    def start_clients( 
                       self, 
                       debug_level=CLIENT_DEBUG_LEVEL_DEFAULT,
                       mount_options=None,
                       replicate_on_close=False
                     ):
        
        for dir_name in ( "log", "mnt" ):
            try: os.mkdir( dir_name )
            except: pass

        certs_dir_path = os.path.abspath( os.path.join( MY_DIR_PATH, "..", "tests", "certs" ) )        
        if self.__server_uri.startswith( "oncrpcs://" ) or self.__server_uri.startswith( "oncrpcg://" ):
            if os.path.exists( certs_dir_path ):
                pkcs12_file_path = os.path.join( certs_dir_path, "Client.p12" )
                pkcs12_passphrase = "passphrase"
            else:
                raise ValueError, "specified oncrpcs server URI, but cannot find certificate directory at " + certs_dir_path
        else:
            pkcs12_file_path = pkcs12_passphrase = None

        volumes = self.__get_volumes()

        # Create volumes
        for volume_i in xrange( 0, len( volumes ), 2 ):
            volume = volumes[volume_i]
            try: 
                volume.create( 
                               debug_level=debug_level,                              
                               mrc_uri=self.__server_uri,                                
                               pkcs12_file_path=pkcs12_file_path,
                               pkcs12_passphrase=pkcs12_passphrase,
                               stripe_width=( replicate_on_close and ( ( volume_i / 2 ) + 1 ) or 1 ),                                                            
                              )
            except: 
                if DEBUG_ME:
                    print "xctl: error creating volume", volume.get_name()
                    traceback.print_exc()
            
        # Mount volumes
        try:
            for volume_i in xrange( len( volumes ) ):
                volume = volumes[volume_i]            
                volume.mount( 
                              debug_level=debug_level,
                              direct_io=( volume_i % 2 == 1 ), # Or have volume.get_direct_io()?
                              dir_uri=self.__server_uri,
                              log_file_path=os.path.join( "log", "client"+str( volume_i )+".log" ),
                              other_options=mount_options,
                              pkcs12_file_path=pkcs12_file_path,
                              pkcs12_passphrase=pkcs12_passphrase,
                              replication_factor=( replicate_on_close and ( ( volume_i / 2 ) + 1 ) or 0 ),
                            )
        except:
            if DEBUG_ME:
                print "xctl: caught exception trying to start autotest clients:"
                traceback.print_exc()            
            
            self.stop_clients()
            raise
                
    def start_servers( 
                       self,
                       debug_level=SERVER_DEBUG_LEVEL_DEFAULT                        
                     ):                
        for dir_name in ( "config", "data", "log" ):
            try: os.mkdir( dir_name )
            except: pass                       

        certs_dir_path = os.path.abspath( os.path.join( MY_DIR_PATH, "..", "tests", "certs" ) )        
        if self.__server_uri.startswith( "oncrpcs://" ) or self.__server_uri.startswith( "oncrpcg://" ):
            if os.path.exists( certs_dir_path ):
                enable_ssl = True
                enable_gridssl = self.__server_uri.startswith( "oncrpcg://" )
            else:
                raise ValueError, "specified oncrpcs server URI, but cannot find certificate directory at " + certs_dir_path
        else:
            enable_ssl = enable_gridssl = False
        
        try:
            dir, mrc, osds = self.__get_servers()
                        
            dir.configure( 
                           database_dir_path=os.path.join( "data", "dir" ),
                           debug_level=debug_level,
                           enable_ssl=enable_ssl,
                           enable_gridssl=enable_gridssl,
                           pkcs12_file_path=os.path.join( certs_dir_path, "DIR.p12" ),
                           pkcs12_passphrase="passphrase",                           
                           trusted_certs_jks_file_path=os.path.join( certs_dir_path, "trusted.jks" ),
                           trusted_certs_jks_passphrase="passphrase",
                           uuid="test-env-DIR" 
                         )                                
            dir.start( log_file_path=os.path.join( "log", "dir.log" ) )
            
            
            mrc.configure( 
                           database_dir_path=os.path.join( "data", "mrc" ),
                           debug_level=debug_level,
                           enable_ssl=enable_ssl,
                           enable_gridssl=enable_gridssl,
                           pkcs12_file_path=os.path.join(  certs_dir_path, "MRC.p12" ),
                           pkcs12_passphrase="passphrase",
                           trusted_certs_jks_file_path=os.path.join( certs_dir_path, "trusted.jks" ),
                           trusted_certs_jks_passphrase="passphrase",
                           uuid="test-env-MRC" 
                         )
            mrc.start( log_file_path=os.path.join( "log", "mrc.log" ) )            


            for osd_i in xrange( len( osds ) ):
                osd = osds[osd_i]                
                osd.configure(
                               debug_level=debug_level, 
                               enable_ssl=enable_ssl,
                               enable_gridssl=enable_gridssl,
                               http_port=OSD_HTTP_PORT_DEFAULT+osd_i,
                               object_dir_path=os.path.join( "data", "osd" + str( osd_i ) ),
                               oncrpc_port=OSD_ONCRPC_PORT_DEFAULT+osd_i,
                               pkcs12_file_path=os.path.join( certs_dir_path, "OSD.p12" ),
                               pkcs12_passphrase="passphrase",                           
                               trusted_certs_jks_file_path=os.path.join( certs_dir_path, "trusted.jks" ),
                               trusted_certs_jks_passphrase="passphrase",
                               uuid="test-env-OSD" + str( osd_i ) 
                             )                             
                osd.start( log_file_path=os.path.join( "log", "osd"+str( osd_i )+".log" ) )
        except:
            if DEBUG_ME:
                print "xctl: caught exception trying to start autotest servers:"
                traceback.print_exc()
            
            self.stop_servers()                    
            raise
                            
    def run( self ):               
        failed_test_count = 0
        for volume in self.__get_volumes():
            failed_test_count += volume.test()
        return failed_test_count
    
    def save_server_status_pages( self ):
        dir, mrc, osds = self.__get_servers()
        dir.save_status_page( "/tmp/dir_status.html" )
        mrc.save_status_page( "/tmp/mrc_status.html" )
        for osd_i in xrange( len( osds ) ):
            osds[osd_i].save_status_page( "/tmp/osd" + str( osd_i ) + ".html" )
    
    def stop_clients( self ):
        for volume in self.__get_volumes():
            volume.unmount()
    
    def stop_servers( self ):                    
        dir, mrc, osds = self.__get_servers()
        dir.stop()
        mrc.stop()
        for osd in osds: 
            osd.stop()


class Server:
    def __init__( self, config_file_path ):
        self.__config_file_path = config_file_path

    def _get_ssl_config( 
                         self, 
                         enable_gridssl=False, 
                         enable_ssl=False, 
                         pkcs12_file_path=None, 
                         pkcs12_passphrase=None, 
                         trusted_certs_jks_file_path=None, 
                         trusted_certs_jks_passphrase=None 
                       ):  
                 
        if enable_ssl:            
            if enable_gridssl:
                gridsslcfg = "ssl.grid_ssl = true\n"
            else:
                gridsslcfg = "ssl.grid_ssl = false\n"
                            
            return """\
ssl.enabled = true
ssl.service_creds = %(pkcs12_file_path)s
ssl.service_creds.pw = %(pkcs12_passphrase)s
ssl.service_creds.container = PKCS12
ssl.trusted_certs = %(trusted_certs_jks_file_path)s
ssl.trusted_certs.pw = %(trusted_certs_jks_passphrase)s
ssl.trusted_certs.container = JKS        
""" % locals() + gridsslcfg
        else:        
            return """\
ssl.enabled = false        
"""                    

    def get_config_file_path( self ):
        return self.__config_file_path

    def __get_config_property( self, key ):
        for line in open( self.__config_file_path ).readlines():
            test_key, value = line.split( "=" )
            test_key = test_key.strip()
            if test_key == key:
                return value.strip()
            
        raise ValueError, key + " = not found in " + self.__config_file_path

    def __get_pid_file_path( self, run_dir_path ):
        return os.path.join( run_dir_path, self.get_uuid() + ".pid" )        

    def get_http_port( self ):
        return int( self.__get_config_property( "http_port" ) )

    def get_oncrpc_port( self ):
        return int( self.__get_config_property( "listen.port" ) )
        
    def get_uuid( self ):
        return self.__get_config_property( "uuid" )

    def is_running( self, run_dir_path=SERVER_RUN_DIR_PATH_DEFAULT ):
        pid_file_path = self.__get_pid_file_path( run_dir_path )
        if os.path.exists( pid_file_path ):
            pid = int( open( pid_file_path ).read().strip() )
            
            if DEBUG_ME:
                print "xctl: checking if", self.__class__.__name__, "server is running with pid", pid
                
            try:
                pid, exitvalue = os.waitpid( pid, os.WNOHANG )
                if pid != 0 and exitvalue != 0:
                    return False
                else:
                    return True
            except OSError:
                return False            
        else:
            return False

    def save_status_page( self, to_file_path ):
        http_port = self.get_http_port()
        os.system( "wget -O %(to_file_path)s http://localhost:%(http_port)u" % locals() )

    def start( 
               self, 
               log_file_path=None, 
               run_dir_path=SERVER_RUN_DIR_PATH_DEFAULT 
             ):

        if not self.is_running( run_dir_path ):        
            try: os.mkdir( run_dir_path )
            except: pass
            pid_file_path = self.__get_pid_file_path( run_dir_path )
                    
            java_args = [os.path.join( os.environ["JAVA_HOME"], "bin", "java" )] 
            java_args.append( "-ea" ) # Enable assertions
    
            # Construct the -cp classpath
            XtreemFS_jar_file_path = os.path.abspath( os.path.join( MY_DIR_PATH, "..", "src", "servers", "dist", "XtreemFS.jar" ) )
            if os.path.exists( XtreemFS_jar_file_path ):
                classpath = ( 
                              XtreemFS_jar_file_path,
                              os.path.abspath( os.path.join( MY_DIR_PATH, "..", "src", "servers", "lib", "BabuDB.jar" ) ),
                              os.path.abspath( os.path.join( MY_DIR_PATH, "..", "src", "servers", "lib", "yidl.jar" ) ),
                            )
                if sys.platform.startswith( "win" ):
                    classpath = ";".join( classpath )
                else:
                    classpath = ":".join( classpath )                
                java_args.extend( ( "-cp", classpath ) )
    
            # Name of the class to start
            java_args.append( "org.xtreemfs." + self.__class__.__name__.lower() + "." + self.__class__.__name__.upper() )
    
            # .config file
            java_args.append( self.get_config_file_path() )
                              
            # Don't .join java_args, since Popen wants a sequence when shell=False
                               
            if log_file_path is None:
                stderr = sys.stderr
                stdout = sys.stdout       
            else:
                # Redirect stderr and stdout to a log file
                stderr = stdout = open( log_file_path, "a" )
            
            if DEBUG_ME:
                print "xctl: starting", self.__class__.__name__, "server with UUID", self.get_uuid(), "on port", self.get_oncrpc_port(), "with", " ".join( java_args )
            
            p = subprocess.Popen( java_args, stdout=stdout, stderr=stderr ) # No shell=True: we only want one process (java), not two (/bin/sh and java)
            open( pid_file_path, "w+" ).write( str( p.pid ) )
    
            if DEBUG_ME:
                print "xctl: started", self.__class__.__name__, "server with UUID", self.get_uuid(), "on port", self.get_oncrpc_port(), "with pid", p.pid        
            
            sleep( 2.0 )
                                            
            if not self.is_running( run_dir_path ):
                raise RuntimeError, self.get_uuid() + " failed to start"
        else:
            print "xctl:", self.__class__.__name__, "server with UUID", self.get_uuid(), "is already running"
                    
    def stop( self, run_dir_path=SERVER_RUN_DIR_PATH_DEFAULT ):
        pid_file_path = self.__get_pid_file_path( run_dir_path )           
        if os.path.exists( pid_file_path ):
            pid = int( open( pid_file_path ).read().strip() )

            if sys.platform.startswith( "win" ):
                subprocess.call( "TASKKILL /PID %(pid)u /F /T" % locals() )
                killed = True
            else:
                killed = False
                for signo in ( signal.SIGTERM, signal.SIGKILL ):
                    for try_i in xrange( SERVER_STOP_TRIES ):
                        if DEBUG_ME:
                            print "xctl: stopping", self.__class__.__name__, "server with pid", pid, "with signal", str( signo ) + ", try", try_i
                                                
                        try: os.kill( pid, signo )
                        except: pass
                
                        sleep( 1 )

                        try:
                            if os.waitpid( pid, os.WNOHANG )[0] != 0: 
                               killed = True
                               break
                        except OSError:
                             killed = True
                             break
                        except:
                            if DEBUG_ME:
                                traceback.print_exc()

                    if killed:
                        break

            if killed:                
                os.unlink( pid_file_path )
               
        elif DEBUG_ME:
            print "xctl: no pid file for", self.__class__.__name__, "server"     
        

class DIR(Server):
    def configure( 
                   self,
                   database_dir_path, 
                   uuid,
                   debug_level=SERVER_DEBUG_LEVEL_DEFAULT, 
                   http_port=DIR_HTTP_PORT_DEFAULT,
                   oncrpc_port=DIR_ONCRPC_PORT_DEFAULT,
                   **kwds 
                 ):

        try: os.mkdir( database_dir_path )
        except: pass
                    
        open( self.get_config_file_path(), "w+" ).write( """\
uuid = %(uuid)s
babudb.debug.level = %(debug_level)s
babudb.logDir = %(database_dir_path)s
babudb.baseDir = %(database_dir_path)s
babudb.sync = FSYNC
babudb.worker.maxQueueLength = 250
babudb.worker.numThreads = 0
babudb.maxLogfileSize = 16777216
babudb.checkInterval = 300
babudb.pseudoSyncWait = 200
debug.level = %(debug_level)s
listen.port = %(oncrpc_port)u
http_port = %(http_port)u
database.dir = %(database_dir_path)s
database.log = %(database_dir_path)s
authentication_provider = org.xtreemfs.common.auth.NullAuthProvider
""" % locals() + self._get_ssl_config( **kwds ) )
         

class MRC(Server):    
    def configure( 
                   self,
                   database_dir_path, 
                   uuid,
                   debug_level=SERVER_DEBUG_LEVEL_DEFAULT,
                   dir_uri=DIR_URI_DEFAULT, 
                   http_port=MRC_HTTP_PORT_DEFAULT,
                   oncrpc_port=MRC_ONCRPC_PORT_DEFAULT,
                   **kwds 
                  ):        
        
        try: os.mkdir( database_dir_path )
        except: pass
                
        dir_service_host = "localhost"
        dir_service_port = DIR_ONCRPC_PORT_DEFAULT
                        
        open( self.get_config_file_path(), "w+" ).write( """\
uuid = %(uuid)s
debug.level = %(debug_level)s
listen.port = %(oncrpc_port)u
http_port = %(http_port)u 
dir_service.host = %(dir_service_host)s
dir_service.port = %(dir_service_port)u
babudb.debug.level = %(debug_level)s
babudb.logDir = %(database_dir_path)s
babudb.baseDir = %(database_dir_path)s
babudb.sync = ASYNC
babudb.worker.maxQueueLength = 250
babudb.worker.numThreads = 0
babudb.maxLogfileSize = 16777216
babudb.checkInterval = 300
babudb.pseudoSyncWait = 0
osd_check_interval = 300
no_atime = true
no_fsync = true
local_clock_renewal = 50
remote_time_sync = 60000
database.dir = %(database_dir_path)s
database.log = %(database_dir_path)s
database.checkpoint.interval = 1800000
database.checkpoint.idle_interval = 1000
database.checkpoint.logfile_size = 16384
authentication_provider = org.xtreemfs.common.auth.NullAuthProvider
capability_secret = testsecret
""" % locals() + self._get_ssl_config( **kwds ) )       


class OSD(Server):        
    def configure( 
                   self,
                   object_dir_path,
                   uuid,
                   debug_level=SERVER_DEBUG_LEVEL_DEFAULT,
                   dir_uri=DIR_URI_DEFAULT, 
                   http_port=OSD_HTTP_PORT_DEFAULT,
                   oncrpc_port=OSD_ONCRPC_PORT_DEFAULT,
                   **kwds 
                 ):               
                
        try: os.mkdir( object_dir_path )
        except: pass

        dir_service_host = "localhost"
        dir_service_port = DIR_ONCRPC_PORT_DEFAULT            
                                                        
        open( self.get_config_file_path(), "w+" ).write( """\
uuid = %(uuid)s
debug.level = %(debug_level)s
listen.port = %(oncrpc_port)u
http_port = %(http_port)u
dir_service.host = %(dir_service_host)s
dir_service.port = %(dir_service_port)u
object_dir=%(object_dir_path)s
local_clock_renewal = 50
remote_time_sync = 60000
report_free_space = true
checksums.enabled = false
capability_secret = testsecret
""" % locals() + self._get_ssl_config( **kwds ) )


class Volume:
    def __init__( self, name, mount_point_dir_path=None ):
        if mount_point_dir_path is not None:
            self.__mount_point_dir_path = os.path.abspath( mount_point_dir_path )
        else:
            self.__mount_point_dir_path = None
        self.__name = name        
    
    def create( 
                self, 
                debug_level=CLIENT_DEBUG_LEVEL_DEFAULT,
                mrc_uri=MRC_URI_DEFAULT,
                pkcs12_file_path=None,
                pkcs12_passphrase=None,
                stripe_width=1,
              ):
        
        mkfs_xtreemfs_file_path = os.path.abspath( os.path.join( MY_DIR_PATH, "mkfs.xtreemfs" ) )
        if not os.path.exists( mkfs_xtreemfs_file_path ):
            mkfs_xtreemfs_file_path = "mkfs.xtreemfs" # Assume it's in the global path
            
        mkfs_xtreemfs_args = [mkfs_xtreemfs_file_path]
        mkfs_xtreemfs_args.extend( ( "-d", str( debug_level ) ) )
        mkfs_xtreemfs_args.extend( ( "-p", str( STRIPING_POLICY_TYPE_DEFAULT ) ) )
        if pkcs12_file_path is not None: mount_xtreemfs_args.extend( ( "--pkcs12-file-path", pkcs12_file_path ) )
        if pkcs12_passphrase is not None: mount_xtreemfs_args.extend( ( "--pkcs12-passphrase", pkcs12_passphrase ) )        
        mkfs_xtreemfs_args.extend( ( "-s", str( STRIPE_SIZE_DEFAULT ) ) )
        mkfs_xtreemfs_args.extend( ( "-w", str( stripe_width ) ) )
          
        if not mrc_uri.endswith( "/" ):
            mrc_uri += "/"          
        mkfs_xtreemfs_args.append( mrc_uri + self.get_name() )

        mkfs_xtreemfs_args = " ".join( mkfs_xtreemfs_args )
        
        if DEBUG_ME:
            print "xctl: creating volume", self.get_name(), "with", mkfs_xtreemfs_args
                               
        subprocess.call( mkfs_xtreemfs_args, shell=True )

    def get_mount_point_dir_path( self ):
        return self.__mount_point_dir_path

    def get_name( self ):
        return self.__name
    
    def mount( 
               self,
               debug_level=CLIENT_DEBUG_LEVEL_DEFAULT,
               dir_uri=DIR_URI_DEFAULT,
               direct_io=False,
               log_file_path=None,
               other_options=None,
               pkcs12_file_path=None,
               pkcs12_passphrase=None,   
               replication_factor=0,         
              ):

        try: os.mkdir( self.get_mount_point_dir_path() )
        except: pass        
                
        mount_xtreemfs_file_path = os.path.abspath( os.path.join( MY_DIR_PATH, "mount.xtreemfs" ) )
        if not os.path.exists( mount_xtreemfs_file_path ):
            mount_xtreemfs_file_path = "mount.xtreemfs" # Assume it's in the global path
 
        mount_xtreemfs_args = [mount_xtreemfs_file_path]                
        mount_xtreemfs_args.append( "-f" ) # So we can redirect stdout and stderr
        mount_xtreemfs_args.extend( ( "-d", str( debug_level ) ) )                                                        
        if direct_io: mount_xtreemfs_args.extend( ( "-o", "direct_io" ) )        
        if other_options is not None:
            assert isinstance( other_options, list )
            for other_option in other_options:
                mount_xtreemfs_args.append( other_option )
        if pkcs12_file_path is not None: mount_xtreemfs_args.extend( ( "--pkcs12-file-path", pkcs12_file_path ) )
        if pkcs12_passphrase is not None: mount_xtreemfs_args.extend( ( "--pkcs12-passphrase", pkcs12_passphrase ) )
        
        volume_uri = dir_uri
        if not volume_uri.endswith( "/" ): volume_uri += "/"
        volume_uri += self.get_name()        
        mount_xtreemfs_args.append( volume_uri )      
                          
        mount_xtreemfs_args.append( self.get_mount_point_dir_path() )

        if log_file_path is None:
            stdout = sys.stdout
            stderr = sys.stderr
        else:
            stderr = stdout = open( log_file_path, "a" )

        if DEBUG_ME:
            print "xctl: mounting volume", self.get_name(), "at", self.get_mount_point_dir_path(), "with", " ".join( mount_xtreemfs_args )
                
        # Use subprocess.Popen instead of subprocess.call to run in the background
        subprocess.Popen( mount_xtreemfs_args, stderr=stderr, stdout=stdout )

        sleep( 2.0 )
        
        if replication_factor > 0:
            for setfattr_command in \
              ( 
                "/usr/bin/setfattr -n xtreemfs.repl_factor -v " + 
                    str( replication_factor ) + " " + self.get_mount_point_dir_path(),
                "/usr/bin/setfattr -n xtreemfs.rsel_policy -v 3000 " + 
                    self.get_mount_point_dir_path() 
              ):
                if DEBUG_ME:
                    print "xctl: calling setfattr to enable replication:", setfattr_command
                subprocess.call( setfattr_command, shell=True )
                          
    def test( 
              self, 
              verbose=False
            ):

        failed_test_count = 0 # The return value
        original_cwd = os.getcwd()

        tests_dir_path = os.path.abspath( os.path.join( MY_DIR_PATH, "..", "tests" ) )
        assert os.path.exists( tests_dir_path ), "xtreemfs/tests directory does not exist!"
        sys.path.append( tests_dir_path )


        try:
            test_suite_factories = {}
            test_module_names = [os.path.splitext( file_name )[0] for file_name in os.listdir( tests_dir_path ) if file_name.endswith( ".py" )]
            test_module_names.sort()
            for test_module_name in test_module_names:
                if DEBUG_ME:
                    print "xctl: trying to import test module", test_module_name
                    
                try:
                    test_module = __import__( test_module_name )
                except ImportError:
                    if DEBUG_ME:
                        print "xctl: could not import test module", test_module_name, "from tests"
                        traceback.print_exc()
                    continue
    
                try: 
                    test_suite_factories[test_module_name] = getattr( test_module, "createTestSuite" )
                except AttributeError:
                    if DEBUG_ME: 
                        print "xctl: test module", test_module_name, "does not have a createTestSuite global function"                        
                            
            test_module_names = test_suite_factories.keys()
            test_module_names.sort()
            for test_module_name in test_module_names:
                test_suite_factory = test_suite_factories[test_module_name]                
                test_suite = test_suite_factory( direct_io=( not "nondirect" in self.get_mount_point_dir_path() ) )
                if test_suite is not None:            
                    test_run_dir_path = os.path.join( self.get_mount_point_dir_path(), test_module_name )
                    try: 
                        os.mkdir( test_run_dir_path )
                    except KeyboardInterrupt:
                        raise
                    except:
                        pass # The directory may already exist because of direct/nondirect volume sharing
                    os.chdir( test_run_dir_path )
                    print "xctl: running", test_module_name, "in", test_run_dir_path

                    result = unittest.TextTestRunner( verbosity=( verbose and 2 or 1 ) ).run( test_suite )
                    if not result.wasSuccessful(): failed_test_count += 1

                    os.chdir( original_cwd ) # Change back so we can rmtree test_run_dir_path
                    try: 
                        shutil.rmtree( test_run_dir_path )
                    except KeyboardInterrupt:
                        raise
                    except:
                        if DEBUG_ME:
                            print "xctl: error cleaning up test directory", test_run_dir_path
                            traceback.print_exc()        

        except KeyboardInterrupt:
            os.chdir( original_cwd )
            raise
        except:
            traceback.print_exc()

        os.chdir( original_cwd )
        return failed_test_count
        
    def unmount( self ):
        for mounts_line in open( "/proc/mounts" ).readlines():
            mounts_line_parts = mounts_line.split()
            test_device = mounts_line_parts[0]
            test_mount_point_dir_path = mounts_line_parts[1]
            if test_device == "xtreemfs" and test_mount_point_dir_path.endswith( self.get_mount_point_dir_path() ):
                fusermount_args = " ".join( ["fusermount", "-u", "-z", self.get_mount_point_dir_path()] )
                if DEBUG_ME:
                    print "xctl: unmounting volume", self.get_name(), "with", fusermount_args
                subprocess.call( fusermount_args, shell=True )        
                       
        
if __name__ == "__main__":
    # Re-open stdout and stderr for unbuffered output
    sys.stderr = os.fdopen( sys.stderr.fileno(), 'w', 0 ) 
    sys.stdout = os.fdopen( sys.stdout.fileno(), 'w', 0 ) 

    option_parser = OptionParser( "usage: %prog [options] [oncrpc://]<server_host=localhost>[:server_port]" )    
    option_parser.add_option( "--autotest", action="store_true", help="start autotest clients and servers, run autotests, stop clients and servers" )
    option_parser.add_option( "--autotest-osd-count", action="store", dest="autotest_osd_count", type="int", default=3 )
    option_parser.add_option( "--clean-autotest", action="store_true", dest="clean_autotest", help="delete autotest directories" )
    option_parser.add_option( "--client-debug-level", action="store", dest="client_debug_level", default=None )
    option_parser.add_option( "-d", "--debug-level", action="store", dest="debug_level", default=None )
    option_parser.add_option( "-o", "--mount-option", action="append", dest="mount_options", help="pass options to mount.xtreemfs" )
    option_parser.add_option( "--run-autotest", action="store_true", dest="run_autotest", help="run autotests (assumes clients and servers are already started and will be stopped manually" )
    option_parser.add_option( "--replicate-on-close", action="store_true", dest="replicate_on_close" )
    option_parser.add_option( "--server-debug-level", action="store", dest="server_debug_level", default=None )
    option_parser.add_option( "--start-autotest-clients", action="store_true", dest="start_autotest_clients" )
    option_parser.add_option( "--start-autotest-servers", action="store_true", dest="start_autotest_servers" )
    option_parser.add_option( "--stop-autotest-clients", action="store_true", dest="stop_autotest_clients" )
    option_parser.add_option( "--stop-autotest-servers", action="store_true", dest="stop_autotest_servers" )        

    options, positional_args = option_parser.parse_args()

    if options.client_debug_level is not None:
        client_debug_level = options.client_debug_level
    elif options.debug_level is not None:
        client_debug_level = options.debug_level 
    else:
        client_debug_level = CLIENT_DEBUG_LEVEL_DEFAULT

    if options.server_debug_level is not None:
        server_debug_level = options.server_debug_level
    elif options.debug_level is not None:
        server_debug_level = options.debug_level 
    else:
        server_debug_level = SERVER_DEBUG_LEVEL_DEFAULT
    
    if len( positional_args ) > 0:
        server_uri = positional_args[0]
        if not "://" in server_uri:
            server_uri = "oncrpc://" + server_uri        
    else:
        server_uri = "oncrpc://localhost"

    if options.autotest or \
       options.clean_autotest or \
       options.run_autotest or \
       options.start_autotest_clients or \
       options.start_autotest_servers or \
       options.stop_autotest_clients or \
       options.stop_autotest_servers:
        
        autotest = Autotest( osd_count=options.autotest_osd_count, server_uri=server_uri )

        if options.clean_autotest:
            autotest.clean()
        else:
            ret = 0
            interrupted = False
                        
            if options.start_autotest_servers or options.autotest:
                autotest.start_servers( debug_level=server_debug_level )
            
            if options.start_autotest_clients or options.autotest:
                autotest.start_clients( 
                                        debug_level=client_debug_level,
                                        mount_options=options.mount_options, 
                                        replicate_on_close=options.replicate_on_close 
                                       )            

            if options.run_autotest or options.autotest:
                try:
                    ret = autotest.run()
                except KeyboardInterrupt:
                    interrupted = True
                
            if options.stop_autotest_clients or options.autotest:
                autotest.stop_clients()

            if options.autotest and not interrupted:
                autotest.save_server_status_pages()
                
            if options.stop_autotest_servers or options.autotest:
                autotest.stop_servers()
                
            sys.exit( ret )
    else:
        option_parser.print_help()
