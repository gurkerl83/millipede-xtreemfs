// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pbrpc/RPC.proto

#ifndef PROTOBUF_pbrpc_2fRPC_2eproto__INCLUDED
#define PROTOBUF_pbrpc_2fRPC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

class UserCredentials;
class AuthPassword;
class Auth;
class RPCHeader;
class RPCHeader_RequestHeader;
class RPCHeader_ErrorResponse;

enum MessageType {
  RPC_REQUEST = 0,
  RPC_RESPONSE_SUCCESS = 1,
  RPC_RESPONSE_ERROR = 2
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = RPC_REQUEST;
const MessageType MessageType_MAX = RPC_RESPONSE_ERROR;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum AuthType {
  AUTH_NONE = 0,
  AUTH_PASSWORD = 1
};
bool AuthType_IsValid(int value);
const AuthType AuthType_MIN = AUTH_NONE;
const AuthType AuthType_MAX = AUTH_PASSWORD;
const int AuthType_ARRAYSIZE = AuthType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthType_descriptor();
inline const ::std::string& AuthType_Name(AuthType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthType_descriptor(), value);
}
inline bool AuthType_Parse(
    const ::std::string& name, AuthType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthType>(
    AuthType_descriptor(), name, value);
}
enum ErrorType {
  INVALID_INTERFACE_ID = 1,
  INVALID_PROC_ID = 2,
  GARBAGE_ARGS = 3,
  AUTH_FAILED = 4,
  INTERNAL_SERVER_ERROR = 5,
  ERRNO = 6,
  REDIRECT = 7,
  IO_ERROR = 100
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = INVALID_INTERFACE_ID;
const ErrorType ErrorType_MAX = IO_ERROR;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum POSIXErrno {
  POSIX_ERROR_NONE = 9999,
  POSIX_ERROR_EPERM = 1,
  POSIX_ERROR_ENOENT = 2,
  POSIX_ERROR_EIO = 5,
  POSIX_ERROR_EAGAIN = 11,
  POSIX_ERROR_EACCES = 13,
  POSIX_ERROR_EEXIST = 17,
  POSIX_ERROR_EXDEV = 18,
  POSIX_ERROR_ENODEV = 19,
  POSIX_ERROR_ENOTDIR = 20,
  POSIX_ERROR_EISDIR = 21,
  POSIX_ERROR_EINVAL = 22,
  POSIX_ERROR_ENOTEMPTY = 39,
  POSIX_ERROR_ENODATA = 61
};
bool POSIXErrno_IsValid(int value);
const POSIXErrno POSIXErrno_MIN = POSIX_ERROR_EPERM;
const POSIXErrno POSIXErrno_MAX = POSIX_ERROR_NONE;
const int POSIXErrno_ARRAYSIZE = POSIXErrno_MAX + 1;

const ::google::protobuf::EnumDescriptor* POSIXErrno_descriptor();
inline const ::std::string& POSIXErrno_Name(POSIXErrno value) {
  return ::google::protobuf::internal::NameOfEnum(
    POSIXErrno_descriptor(), value);
}
inline bool POSIXErrno_Parse(
    const ::std::string& name, POSIXErrno* value) {
  return ::google::protobuf::internal::ParseNamedEnum<POSIXErrno>(
    POSIXErrno_descriptor(), name, value);
}
// ===================================================================

class UserCredentials : public ::google::protobuf::Message {
 public:
  UserCredentials();
  virtual ~UserCredentials();
  
  UserCredentials(const UserCredentials& from);
  
  inline UserCredentials& operator=(const UserCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCredentials& default_instance();
  
  void Swap(UserCredentials* other);
  
  // implements Message ----------------------------------------------
  
  UserCredentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserCredentials& from);
  void MergeFrom(const UserCredentials& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  
  // repeated string groups = 2;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 2;
  inline const ::std::string& groups(int index) const;
  inline ::std::string* mutable_groups(int index);
  inline void set_groups(int index, const ::std::string& value);
  inline void set_groups(int index, const char* value);
  inline void set_groups(int index, const char* value, size_t size);
  inline ::std::string* add_groups();
  inline void add_groups(const ::std::string& value);
  inline void add_groups(const char* value);
  inline void add_groups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.UserCredentials)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* username_;
  static const ::std::string _default_username_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;
  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserCredentials* default_instance_;
};
// -------------------------------------------------------------------

class AuthPassword : public ::google::protobuf::Message {
 public:
  AuthPassword();
  virtual ~AuthPassword();
  
  AuthPassword(const AuthPassword& from);
  
  inline AuthPassword& operator=(const AuthPassword& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthPassword& default_instance();
  
  void Swap(AuthPassword* other);
  
  // implements Message ----------------------------------------------
  
  AuthPassword* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthPassword& from);
  void MergeFrom(const AuthPassword& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string password = 1;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 1;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.AuthPassword)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* password_;
  static const ::std::string _default_password_;
  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AuthPassword* default_instance_;
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message {
 public:
  Auth();
  virtual ~Auth();
  
  Auth(const Auth& from);
  
  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();
  
  void Swap(Auth* other);
  
  // implements Message ----------------------------------------------
  
  Auth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.AuthType auth_type = 1;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 1;
  inline xtreemfs::pbrpc::AuthType auth_type() const;
  inline void set_auth_type(xtreemfs::pbrpc::AuthType value);
  
  // optional .xtreemfs.pbrpc.AuthPassword auth_passwd = 3;
  inline bool has_auth_passwd() const;
  inline void clear_auth_passwd();
  static const int kAuthPasswdFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::AuthPassword& auth_passwd() const;
  inline ::xtreemfs::pbrpc::AuthPassword* mutable_auth_passwd();
  
  // optional bytes auth_data = 2;
  inline bool has_auth_data() const;
  inline void clear_auth_data();
  static const int kAuthDataFieldNumber = 2;
  inline const ::std::string& auth_data() const;
  inline void set_auth_data(const ::std::string& value);
  inline void set_auth_data(const char* value);
  inline void set_auth_data(const void* value, size_t size);
  inline ::std::string* mutable_auth_data();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Auth)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int auth_type_;
  ::xtreemfs::pbrpc::AuthPassword* auth_passwd_;
  ::std::string* auth_data_;
  static const ::std::string _default_auth_data_;
  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Auth* default_instance_;
};
// -------------------------------------------------------------------

class RPCHeader_RequestHeader : public ::google::protobuf::Message {
 public:
  RPCHeader_RequestHeader();
  virtual ~RPCHeader_RequestHeader();
  
  RPCHeader_RequestHeader(const RPCHeader_RequestHeader& from);
  
  inline RPCHeader_RequestHeader& operator=(const RPCHeader_RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCHeader_RequestHeader& default_instance();
  
  void Swap(RPCHeader_RequestHeader* other);
  
  // implements Message ----------------------------------------------
  
  RPCHeader_RequestHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCHeader_RequestHeader& from);
  void MergeFrom(const RPCHeader_RequestHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 interface_id = 1;
  inline bool has_interface_id() const;
  inline void clear_interface_id();
  static const int kInterfaceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 interface_id() const;
  inline void set_interface_id(::google::protobuf::uint32 value);
  
  // required fixed32 proc_id = 2;
  inline bool has_proc_id() const;
  inline void clear_proc_id();
  static const int kProcIdFieldNumber = 2;
  inline ::google::protobuf::uint32 proc_id() const;
  inline void set_proc_id(::google::protobuf::uint32 value);
  
  // required .xtreemfs.pbrpc.UserCredentials user_creds = 3;
  inline bool has_user_creds() const;
  inline void clear_user_creds();
  static const int kUserCredsFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::UserCredentials& user_creds() const;
  inline ::xtreemfs::pbrpc::UserCredentials* mutable_user_creds();
  
  // required .xtreemfs.pbrpc.Auth auth_data = 4;
  inline bool has_auth_data() const;
  inline void clear_auth_data();
  static const int kAuthDataFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::Auth& auth_data() const;
  inline ::xtreemfs::pbrpc::Auth* mutable_auth_data();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.RPCHeader.RequestHeader)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 interface_id_;
  ::google::protobuf::uint32 proc_id_;
  ::xtreemfs::pbrpc::UserCredentials* user_creds_;
  ::xtreemfs::pbrpc::Auth* auth_data_;
  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RPCHeader_RequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class RPCHeader_ErrorResponse : public ::google::protobuf::Message {
 public:
  RPCHeader_ErrorResponse();
  virtual ~RPCHeader_ErrorResponse();
  
  RPCHeader_ErrorResponse(const RPCHeader_ErrorResponse& from);
  
  inline RPCHeader_ErrorResponse& operator=(const RPCHeader_ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCHeader_ErrorResponse& default_instance();
  
  void Swap(RPCHeader_ErrorResponse* other);
  
  // implements Message ----------------------------------------------
  
  RPCHeader_ErrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCHeader_ErrorResponse& from);
  void MergeFrom(const RPCHeader_ErrorResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.ErrorType error_type = 1;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  inline xtreemfs::pbrpc::ErrorType error_type() const;
  inline void set_error_type(xtreemfs::pbrpc::ErrorType value);
  
  // optional .xtreemfs.pbrpc.POSIXErrno posix_errno = 2 [default = POSIX_ERROR_NONE];
  inline bool has_posix_errno() const;
  inline void clear_posix_errno();
  static const int kPosixErrnoFieldNumber = 2;
  inline xtreemfs::pbrpc::POSIXErrno posix_errno() const;
  inline void set_posix_errno(xtreemfs::pbrpc::POSIXErrno value);
  
  // optional string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  
  // optional string debug_info = 4;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 4;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  
  // optional string redirect_to_server_uuid = 5;
  inline bool has_redirect_to_server_uuid() const;
  inline void clear_redirect_to_server_uuid();
  static const int kRedirectToServerUuidFieldNumber = 5;
  inline const ::std::string& redirect_to_server_uuid() const;
  inline void set_redirect_to_server_uuid(const ::std::string& value);
  inline void set_redirect_to_server_uuid(const char* value);
  inline void set_redirect_to_server_uuid(const char* value, size_t size);
  inline ::std::string* mutable_redirect_to_server_uuid();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.RPCHeader.ErrorResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int error_type_;
  int posix_errno_;
  ::std::string* error_message_;
  static const ::std::string _default_error_message_;
  ::std::string* debug_info_;
  static const ::std::string _default_debug_info_;
  ::std::string* redirect_to_server_uuid_;
  static const ::std::string _default_redirect_to_server_uuid_;
  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RPCHeader_ErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class RPCHeader : public ::google::protobuf::Message {
 public:
  RPCHeader();
  virtual ~RPCHeader();
  
  RPCHeader(const RPCHeader& from);
  
  inline RPCHeader& operator=(const RPCHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCHeader& default_instance();
  
  void Swap(RPCHeader* other);
  
  // implements Message ----------------------------------------------
  
  RPCHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCHeader& from);
  void MergeFrom(const RPCHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RPCHeader_RequestHeader RequestHeader;
  typedef RPCHeader_ErrorResponse ErrorResponse;
  
  // accessors -------------------------------------------------------
  
  // required fixed32 call_id = 1;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 1;
  inline ::google::protobuf::uint32 call_id() const;
  inline void set_call_id(::google::protobuf::uint32 value);
  
  // required .xtreemfs.pbrpc.MessageType message_type = 2;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  inline xtreemfs::pbrpc::MessageType message_type() const;
  inline void set_message_type(xtreemfs::pbrpc::MessageType value);
  
  // optional .xtreemfs.pbrpc.RPCHeader.RequestHeader request_header = 3;
  inline bool has_request_header() const;
  inline void clear_request_header();
  static const int kRequestHeaderFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::RPCHeader_RequestHeader& request_header() const;
  inline ::xtreemfs::pbrpc::RPCHeader_RequestHeader* mutable_request_header();
  
  // optional .xtreemfs.pbrpc.RPCHeader.ErrorResponse error_response = 4;
  inline bool has_error_response() const;
  inline void clear_error_response();
  static const int kErrorResponseFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::RPCHeader_ErrorResponse& error_response() const;
  inline ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* mutable_error_response();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.RPCHeader)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 call_id_;
  int message_type_;
  ::xtreemfs::pbrpc::RPCHeader_RequestHeader* request_header_;
  ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* error_response_;
  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RPCHeader* default_instance_;
};
// ===================================================================


// ===================================================================

// UserCredentials

// required string username = 1;
inline bool UserCredentials::has_username() const {
  return _has_bit(0);
}
inline void UserCredentials::clear_username() {
  if (username_ != &_default_username_) {
    username_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UserCredentials::username() const {
  return *username_;
}
inline void UserCredentials::set_username(const ::std::string& value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserCredentials::set_username(const char* value) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserCredentials::set_username(const char* value, size_t size) {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCredentials::mutable_username() {
  _set_bit(0);
  if (username_ == &_default_username_) {
    username_ = new ::std::string;
  }
  return username_;
}

// repeated string groups = 2;
inline int UserCredentials::groups_size() const {
  return groups_.size();
}
inline void UserCredentials::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& UserCredentials::groups(int index) const {
  return groups_.Get(index);
}
inline ::std::string* UserCredentials::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline void UserCredentials::set_groups(int index, const ::std::string& value) {
  groups_.Mutable(index)->assign(value);
}
inline void UserCredentials::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
}
inline void UserCredentials::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCredentials::add_groups() {
  return groups_.Add();
}
inline void UserCredentials::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
}
inline void UserCredentials::add_groups(const char* value) {
  groups_.Add()->assign(value);
}
inline void UserCredentials::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserCredentials::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserCredentials::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// AuthPassword

// required string password = 1;
inline bool AuthPassword::has_password() const {
  return _has_bit(0);
}
inline void AuthPassword::clear_password() {
  if (password_ != &_default_password_) {
    password_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AuthPassword::password() const {
  return *password_;
}
inline void AuthPassword::set_password(const ::std::string& value) {
  _set_bit(0);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AuthPassword::set_password(const char* value) {
  _set_bit(0);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AuthPassword::set_password(const char* value, size_t size) {
  _set_bit(0);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthPassword::mutable_password() {
  _set_bit(0);
  if (password_ == &_default_password_) {
    password_ = new ::std::string;
  }
  return password_;
}

// -------------------------------------------------------------------

// Auth

// required .xtreemfs.pbrpc.AuthType auth_type = 1;
inline bool Auth::has_auth_type() const {
  return _has_bit(0);
}
inline void Auth::clear_auth_type() {
  auth_type_ = 0;
  _clear_bit(0);
}
inline xtreemfs::pbrpc::AuthType Auth::auth_type() const {
  return static_cast< xtreemfs::pbrpc::AuthType >(auth_type_);
}
inline void Auth::set_auth_type(xtreemfs::pbrpc::AuthType value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::AuthType_IsValid(value));
  _set_bit(0);
  auth_type_ = value;
}

// optional .xtreemfs.pbrpc.AuthPassword auth_passwd = 3;
inline bool Auth::has_auth_passwd() const {
  return _has_bit(1);
}
inline void Auth::clear_auth_passwd() {
  if (auth_passwd_ != NULL) auth_passwd_->::xtreemfs::pbrpc::AuthPassword::Clear();
  _clear_bit(1);
}
inline const ::xtreemfs::pbrpc::AuthPassword& Auth::auth_passwd() const {
  return auth_passwd_ != NULL ? *auth_passwd_ : *default_instance_->auth_passwd_;
}
inline ::xtreemfs::pbrpc::AuthPassword* Auth::mutable_auth_passwd() {
  _set_bit(1);
  if (auth_passwd_ == NULL) auth_passwd_ = new ::xtreemfs::pbrpc::AuthPassword;
  return auth_passwd_;
}

// optional bytes auth_data = 2;
inline bool Auth::has_auth_data() const {
  return _has_bit(2);
}
inline void Auth::clear_auth_data() {
  if (auth_data_ != &_default_auth_data_) {
    auth_data_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Auth::auth_data() const {
  return *auth_data_;
}
inline void Auth::set_auth_data(const ::std::string& value) {
  _set_bit(2);
  if (auth_data_ == &_default_auth_data_) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
}
inline void Auth::set_auth_data(const char* value) {
  _set_bit(2);
  if (auth_data_ == &_default_auth_data_) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
}
inline void Auth::set_auth_data(const void* value, size_t size) {
  _set_bit(2);
  if (auth_data_ == &_default_auth_data_) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Auth::mutable_auth_data() {
  _set_bit(2);
  if (auth_data_ == &_default_auth_data_) {
    auth_data_ = new ::std::string;
  }
  return auth_data_;
}

// -------------------------------------------------------------------

// RPCHeader_RequestHeader

// required fixed32 interface_id = 1;
inline bool RPCHeader_RequestHeader::has_interface_id() const {
  return _has_bit(0);
}
inline void RPCHeader_RequestHeader::clear_interface_id() {
  interface_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RPCHeader_RequestHeader::interface_id() const {
  return interface_id_;
}
inline void RPCHeader_RequestHeader::set_interface_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  interface_id_ = value;
}

// required fixed32 proc_id = 2;
inline bool RPCHeader_RequestHeader::has_proc_id() const {
  return _has_bit(1);
}
inline void RPCHeader_RequestHeader::clear_proc_id() {
  proc_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 RPCHeader_RequestHeader::proc_id() const {
  return proc_id_;
}
inline void RPCHeader_RequestHeader::set_proc_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  proc_id_ = value;
}

// required .xtreemfs.pbrpc.UserCredentials user_creds = 3;
inline bool RPCHeader_RequestHeader::has_user_creds() const {
  return _has_bit(2);
}
inline void RPCHeader_RequestHeader::clear_user_creds() {
  if (user_creds_ != NULL) user_creds_->::xtreemfs::pbrpc::UserCredentials::Clear();
  _clear_bit(2);
}
inline const ::xtreemfs::pbrpc::UserCredentials& RPCHeader_RequestHeader::user_creds() const {
  return user_creds_ != NULL ? *user_creds_ : *default_instance_->user_creds_;
}
inline ::xtreemfs::pbrpc::UserCredentials* RPCHeader_RequestHeader::mutable_user_creds() {
  _set_bit(2);
  if (user_creds_ == NULL) user_creds_ = new ::xtreemfs::pbrpc::UserCredentials;
  return user_creds_;
}

// required .xtreemfs.pbrpc.Auth auth_data = 4;
inline bool RPCHeader_RequestHeader::has_auth_data() const {
  return _has_bit(3);
}
inline void RPCHeader_RequestHeader::clear_auth_data() {
  if (auth_data_ != NULL) auth_data_->::xtreemfs::pbrpc::Auth::Clear();
  _clear_bit(3);
}
inline const ::xtreemfs::pbrpc::Auth& RPCHeader_RequestHeader::auth_data() const {
  return auth_data_ != NULL ? *auth_data_ : *default_instance_->auth_data_;
}
inline ::xtreemfs::pbrpc::Auth* RPCHeader_RequestHeader::mutable_auth_data() {
  _set_bit(3);
  if (auth_data_ == NULL) auth_data_ = new ::xtreemfs::pbrpc::Auth;
  return auth_data_;
}

// -------------------------------------------------------------------

// RPCHeader_ErrorResponse

// required .xtreemfs.pbrpc.ErrorType error_type = 1;
inline bool RPCHeader_ErrorResponse::has_error_type() const {
  return _has_bit(0);
}
inline void RPCHeader_ErrorResponse::clear_error_type() {
  error_type_ = 1;
  _clear_bit(0);
}
inline xtreemfs::pbrpc::ErrorType RPCHeader_ErrorResponse::error_type() const {
  return static_cast< xtreemfs::pbrpc::ErrorType >(error_type_);
}
inline void RPCHeader_ErrorResponse::set_error_type(xtreemfs::pbrpc::ErrorType value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::ErrorType_IsValid(value));
  _set_bit(0);
  error_type_ = value;
}

// optional .xtreemfs.pbrpc.POSIXErrno posix_errno = 2 [default = POSIX_ERROR_NONE];
inline bool RPCHeader_ErrorResponse::has_posix_errno() const {
  return _has_bit(1);
}
inline void RPCHeader_ErrorResponse::clear_posix_errno() {
  posix_errno_ = 9999;
  _clear_bit(1);
}
inline xtreemfs::pbrpc::POSIXErrno RPCHeader_ErrorResponse::posix_errno() const {
  return static_cast< xtreemfs::pbrpc::POSIXErrno >(posix_errno_);
}
inline void RPCHeader_ErrorResponse::set_posix_errno(xtreemfs::pbrpc::POSIXErrno value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::POSIXErrno_IsValid(value));
  _set_bit(1);
  posix_errno_ = value;
}

// optional string error_message = 3;
inline bool RPCHeader_ErrorResponse::has_error_message() const {
  return _has_bit(2);
}
inline void RPCHeader_ErrorResponse::clear_error_message() {
  if (error_message_ != &_default_error_message_) {
    error_message_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RPCHeader_ErrorResponse::error_message() const {
  return *error_message_;
}
inline void RPCHeader_ErrorResponse::set_error_message(const ::std::string& value) {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_error_message(const char* value) {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_error_message(const char* value, size_t size) {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCHeader_ErrorResponse::mutable_error_message() {
  _set_bit(2);
  if (error_message_ == &_default_error_message_) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}

// optional string debug_info = 4;
inline bool RPCHeader_ErrorResponse::has_debug_info() const {
  return _has_bit(3);
}
inline void RPCHeader_ErrorResponse::clear_debug_info() {
  if (debug_info_ != &_default_debug_info_) {
    debug_info_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RPCHeader_ErrorResponse::debug_info() const {
  return *debug_info_;
}
inline void RPCHeader_ErrorResponse::set_debug_info(const ::std::string& value) {
  _set_bit(3);
  if (debug_info_ == &_default_debug_info_) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_debug_info(const char* value) {
  _set_bit(3);
  if (debug_info_ == &_default_debug_info_) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_debug_info(const char* value, size_t size) {
  _set_bit(3);
  if (debug_info_ == &_default_debug_info_) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCHeader_ErrorResponse::mutable_debug_info() {
  _set_bit(3);
  if (debug_info_ == &_default_debug_info_) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}

// optional string redirect_to_server_uuid = 5;
inline bool RPCHeader_ErrorResponse::has_redirect_to_server_uuid() const {
  return _has_bit(4);
}
inline void RPCHeader_ErrorResponse::clear_redirect_to_server_uuid() {
  if (redirect_to_server_uuid_ != &_default_redirect_to_server_uuid_) {
    redirect_to_server_uuid_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& RPCHeader_ErrorResponse::redirect_to_server_uuid() const {
  return *redirect_to_server_uuid_;
}
inline void RPCHeader_ErrorResponse::set_redirect_to_server_uuid(const ::std::string& value) {
  _set_bit(4);
  if (redirect_to_server_uuid_ == &_default_redirect_to_server_uuid_) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  redirect_to_server_uuid_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_redirect_to_server_uuid(const char* value) {
  _set_bit(4);
  if (redirect_to_server_uuid_ == &_default_redirect_to_server_uuid_) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  redirect_to_server_uuid_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_redirect_to_server_uuid(const char* value, size_t size) {
  _set_bit(4);
  if (redirect_to_server_uuid_ == &_default_redirect_to_server_uuid_) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  redirect_to_server_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCHeader_ErrorResponse::mutable_redirect_to_server_uuid() {
  _set_bit(4);
  if (redirect_to_server_uuid_ == &_default_redirect_to_server_uuid_) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  return redirect_to_server_uuid_;
}

// -------------------------------------------------------------------

// RPCHeader

// required fixed32 call_id = 1;
inline bool RPCHeader::has_call_id() const {
  return _has_bit(0);
}
inline void RPCHeader::clear_call_id() {
  call_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RPCHeader::call_id() const {
  return call_id_;
}
inline void RPCHeader::set_call_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  call_id_ = value;
}

// required .xtreemfs.pbrpc.MessageType message_type = 2;
inline bool RPCHeader::has_message_type() const {
  return _has_bit(1);
}
inline void RPCHeader::clear_message_type() {
  message_type_ = 0;
  _clear_bit(1);
}
inline xtreemfs::pbrpc::MessageType RPCHeader::message_type() const {
  return static_cast< xtreemfs::pbrpc::MessageType >(message_type_);
}
inline void RPCHeader::set_message_type(xtreemfs::pbrpc::MessageType value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::MessageType_IsValid(value));
  _set_bit(1);
  message_type_ = value;
}

// optional .xtreemfs.pbrpc.RPCHeader.RequestHeader request_header = 3;
inline bool RPCHeader::has_request_header() const {
  return _has_bit(2);
}
inline void RPCHeader::clear_request_header() {
  if (request_header_ != NULL) request_header_->::xtreemfs::pbrpc::RPCHeader_RequestHeader::Clear();
  _clear_bit(2);
}
inline const ::xtreemfs::pbrpc::RPCHeader_RequestHeader& RPCHeader::request_header() const {
  return request_header_ != NULL ? *request_header_ : *default_instance_->request_header_;
}
inline ::xtreemfs::pbrpc::RPCHeader_RequestHeader* RPCHeader::mutable_request_header() {
  _set_bit(2);
  if (request_header_ == NULL) request_header_ = new ::xtreemfs::pbrpc::RPCHeader_RequestHeader;
  return request_header_;
}

// optional .xtreemfs.pbrpc.RPCHeader.ErrorResponse error_response = 4;
inline bool RPCHeader::has_error_response() const {
  return _has_bit(3);
}
inline void RPCHeader::clear_error_response() {
  if (error_response_ != NULL) error_response_->::xtreemfs::pbrpc::RPCHeader_ErrorResponse::Clear();
  _clear_bit(3);
}
inline const ::xtreemfs::pbrpc::RPCHeader_ErrorResponse& RPCHeader::error_response() const {
  return error_response_ != NULL ? *error_response_ : *default_instance_->error_response_;
}
inline ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* RPCHeader::mutable_error_response() {
  _set_bit(3);
  if (error_response_ == NULL) error_response_ = new ::xtreemfs::pbrpc::RPCHeader_ErrorResponse;
  return error_response_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::MessageType>() {
  return xtreemfs::pbrpc::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::AuthType>() {
  return xtreemfs::pbrpc::AuthType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::ErrorType>() {
  return xtreemfs::pbrpc::ErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::POSIXErrno>() {
  return xtreemfs::pbrpc::POSIXErrno_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pbrpc_2fRPC_2eproto__INCLUDED
