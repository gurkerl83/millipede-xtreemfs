// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/MRC.proto

#ifndef PROTOBUF_xtreemfs_2fMRC_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fMRC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/service.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
#include "xtreemfs/GlobalTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

class Stat;
class DirectoryEntry;
class DirectoryEntries;
class XAttr;
class Volume;
class Volumes;
class StatVFS;
class fsetattrRequest;
class getattrRequest;
class getattrResponse;
class getxattrRequest;
class getxattrResponse;
class linkRequest;
class listxattrRequest;
class listxattrResponse;
class mkdirRequest;
class openRequest;
class openResponse;
class readdirRequest;
class readlinkRequest;
class readlinkResponse;
class removexattrRequest;
class renameRequest;
class renameResponse;
class rmdirRequest;
class setattrRequest;
class setxattrRequest;
class statvfsRequest;
class symlinkRequest;
class unlinkRequest;
class unlinkResponse;
class accessRequest;
class xtreemfs_check_file_existsRequest;
class xtreemfs_dump_restore_databaseRequest;
class xtreemfs_get_suitable_osdsRequest;
class xtreemfs_get_suitable_osdsResponse;
class xtreemfs_check_file_existsResponse;
class timestampResponse;
class stringMessage;
class xtreemfs_listdirRequest;
class xtreemfs_listdirResponse;
class xtreemfs_replica_addRequest;
class xtreemfs_replica_listRequest;
class xtreemfs_replica_removeRequest;
class xtreemfs_restore_fileRequest;
class xtreemfs_rmvolRequest;
class xtreemfs_update_file_sizeRequest;
class xtreemfs_set_replica_update_policyRequest;
class xtreemfs_set_replica_update_policyResponse;
class xtreemfs_set_read_only_xattrRequest;
class xtreemfs_set_read_only_xattrResponse;
class xtreemfs_get_file_credentialsRequest;

enum Setattrs {
  SETATTR_MODE = 1,
  SETATTR_UID = 2,
  SETATTR_GID = 4,
  SETATTR_SIZE = 8,
  SETATTR_ATIME = 16,
  SETATTR_MTIME = 32,
  SETATTR_CTIME = 64,
  SETATTR_ATTRIBUTES = 128
};
bool Setattrs_IsValid(int value);
const Setattrs Setattrs_MIN = SETATTR_MODE;
const Setattrs Setattrs_MAX = SETATTR_ATTRIBUTES;
const int Setattrs_ARRAYSIZE = Setattrs_MAX + 1;

const ::google::protobuf::EnumDescriptor* Setattrs_descriptor();
inline const ::std::string& Setattrs_Name(Setattrs value) {
  return ::google::protobuf::internal::NameOfEnum(
    Setattrs_descriptor(), value);
}
inline bool Setattrs_Parse(
    const ::std::string& name, Setattrs* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Setattrs>(
    Setattrs_descriptor(), name, value);
}
enum XATTR_FLAGS {
  XATTR_FLAGS_CREATE = 1,
  XATTR_FLAGS_REPLACE = 2
};
bool XATTR_FLAGS_IsValid(int value);
const XATTR_FLAGS XATTR_FLAGS_MIN = XATTR_FLAGS_CREATE;
const XATTR_FLAGS XATTR_FLAGS_MAX = XATTR_FLAGS_REPLACE;
const int XATTR_FLAGS_ARRAYSIZE = XATTR_FLAGS_MAX + 1;

const ::google::protobuf::EnumDescriptor* XATTR_FLAGS_descriptor();
inline const ::std::string& XATTR_FLAGS_Name(XATTR_FLAGS value) {
  return ::google::protobuf::internal::NameOfEnum(
    XATTR_FLAGS_descriptor(), value);
}
inline bool XATTR_FLAGS_Parse(
    const ::std::string& name, XATTR_FLAGS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XATTR_FLAGS>(
    XATTR_FLAGS_descriptor(), name, value);
}
enum ACCESS_FLAGS {
  ACCESS_FLAGS_F_OK = 0,
  ACCESS_FLAGS_X_OK = 1,
  ACCESS_FLAGS_W_OK = 2,
  ACCESS_FLAGS_R_OK = 4
};
bool ACCESS_FLAGS_IsValid(int value);
const ACCESS_FLAGS ACCESS_FLAGS_MIN = ACCESS_FLAGS_F_OK;
const ACCESS_FLAGS ACCESS_FLAGS_MAX = ACCESS_FLAGS_R_OK;
const int ACCESS_FLAGS_ARRAYSIZE = ACCESS_FLAGS_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCESS_FLAGS_descriptor();
inline const ::std::string& ACCESS_FLAGS_Name(ACCESS_FLAGS value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCESS_FLAGS_descriptor(), value);
}
inline bool ACCESS_FLAGS_Parse(
    const ::std::string& name, ACCESS_FLAGS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCESS_FLAGS>(
    ACCESS_FLAGS_descriptor(), name, value);
}
// ===================================================================

class Stat : public ::google::protobuf::Message {
 public:
  Stat();
  virtual ~Stat();
  
  Stat(const Stat& from);
  
  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stat& default_instance();
  
  void Swap(Stat* other);
  
  // implements Message ----------------------------------------------
  
  Stat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stat& from);
  void MergeFrom(const Stat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed64 dev = 1;
  inline bool has_dev() const;
  inline void clear_dev();
  static const int kDevFieldNumber = 1;
  inline ::google::protobuf::uint64 dev() const;
  inline void set_dev(::google::protobuf::uint64 value);
  
  // required fixed64 ino = 2;
  inline bool has_ino() const;
  inline void clear_ino();
  static const int kInoFieldNumber = 2;
  inline ::google::protobuf::uint64 ino() const;
  inline void set_ino(::google::protobuf::uint64 value);
  
  // required fixed32 mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);
  
  // required fixed32 nlink = 4;
  inline bool has_nlink() const;
  inline void clear_nlink();
  static const int kNlinkFieldNumber = 4;
  inline ::google::protobuf::uint32 nlink() const;
  inline void set_nlink(::google::protobuf::uint32 value);
  
  // required string user_id = 5;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  
  // required string group_id = 6;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 6;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  
  // required fixed64 size = 7;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required fixed64 atime_ns = 8;
  inline bool has_atime_ns() const;
  inline void clear_atime_ns();
  static const int kAtimeNsFieldNumber = 8;
  inline ::google::protobuf::uint64 atime_ns() const;
  inline void set_atime_ns(::google::protobuf::uint64 value);
  
  // required fixed64 mtime_ns = 9;
  inline bool has_mtime_ns() const;
  inline void clear_mtime_ns();
  static const int kMtimeNsFieldNumber = 9;
  inline ::google::protobuf::uint64 mtime_ns() const;
  inline void set_mtime_ns(::google::protobuf::uint64 value);
  
  // required fixed64 ctime_ns = 10;
  inline bool has_ctime_ns() const;
  inline void clear_ctime_ns();
  static const int kCtimeNsFieldNumber = 10;
  inline ::google::protobuf::uint64 ctime_ns() const;
  inline void set_ctime_ns(::google::protobuf::uint64 value);
  
  // required fixed32 blksize = 11;
  inline bool has_blksize() const;
  inline void clear_blksize();
  static const int kBlksizeFieldNumber = 11;
  inline ::google::protobuf::uint32 blksize() const;
  inline void set_blksize(::google::protobuf::uint32 value);
  
  // optional fixed64 etag = 12;
  inline bool has_etag() const;
  inline void clear_etag();
  static const int kEtagFieldNumber = 12;
  inline ::google::protobuf::uint64 etag() const;
  inline void set_etag(::google::protobuf::uint64 value);
  
  // required fixed32 truncate_epoch = 13;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 13;
  inline ::google::protobuf::uint32 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint32 value);
  
  // optional fixed32 attributes = 14;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 14;
  inline ::google::protobuf::uint32 attributes() const;
  inline void set_attributes(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Stat)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 dev_;
  ::google::protobuf::uint64 ino_;
  ::google::protobuf::uint32 mode_;
  ::google::protobuf::uint32 nlink_;
  ::std::string* user_id_;
  static const ::std::string _default_user_id_;
  ::std::string* group_id_;
  static const ::std::string _default_group_id_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 atime_ns_;
  ::google::protobuf::uint64 mtime_ns_;
  ::google::protobuf::uint64 ctime_ns_;
  ::google::protobuf::uint32 blksize_;
  ::google::protobuf::uint64 etag_;
  ::google::protobuf::uint32 truncate_epoch_;
  ::google::protobuf::uint32 attributes_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Stat* default_instance_;
};
// -------------------------------------------------------------------

class DirectoryEntry : public ::google::protobuf::Message {
 public:
  DirectoryEntry();
  virtual ~DirectoryEntry();
  
  DirectoryEntry(const DirectoryEntry& from);
  
  inline DirectoryEntry& operator=(const DirectoryEntry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectoryEntry& default_instance();
  
  void Swap(DirectoryEntry* other);
  
  // implements Message ----------------------------------------------
  
  DirectoryEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectoryEntry& from);
  void MergeFrom(const DirectoryEntry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional .xtreemfs.pbrpc.Stat stbuf = 2;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.DirectoryEntry)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::xtreemfs::pbrpc::Stat* stbuf_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DirectoryEntry* default_instance_;
};
// -------------------------------------------------------------------

class DirectoryEntries : public ::google::protobuf::Message {
 public:
  DirectoryEntries();
  virtual ~DirectoryEntries();
  
  DirectoryEntries(const DirectoryEntries& from);
  
  inline DirectoryEntries& operator=(const DirectoryEntries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectoryEntries& default_instance();
  
  void Swap(DirectoryEntries* other);
  
  // implements Message ----------------------------------------------
  
  DirectoryEntries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectoryEntries& from);
  void MergeFrom(const DirectoryEntries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .xtreemfs.pbrpc.DirectoryEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::DirectoryEntry& entries(int index) const;
  inline ::xtreemfs::pbrpc::DirectoryEntry* mutable_entries(int index);
  inline ::xtreemfs::pbrpc::DirectoryEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >*
      mutable_entries();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.DirectoryEntries)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry > entries_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DirectoryEntries* default_instance_;
};
// -------------------------------------------------------------------

class XAttr : public ::google::protobuf::Message {
 public:
  XAttr();
  virtual ~XAttr();
  
  XAttr(const XAttr& from);
  
  inline XAttr& operator=(const XAttr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XAttr& default_instance();
  
  void Swap(XAttr* other);
  
  // implements Message ----------------------------------------------
  
  XAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XAttr& from);
  void MergeFrom(const XAttr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.XAttr)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static XAttr* default_instance_;
};
// -------------------------------------------------------------------

class Volume : public ::google::protobuf::Message {
 public:
  Volume();
  virtual ~Volume();
  
  Volume(const Volume& from);
  
  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume& default_instance();
  
  void Swap(Volume* other);
  
  // implements Message ----------------------------------------------
  
  Volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 1;
  inline bool has_access_control_policy() const;
  inline void clear_access_control_policy();
  static const int kAccessControlPolicyFieldNumber = 1;
  inline xtreemfs::pbrpc::AccessControlPolicyType access_control_policy() const;
  inline void set_access_control_policy(xtreemfs::pbrpc::AccessControlPolicyType value);
  
  // required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 2;
  inline bool has_default_striping_policy() const;
  inline void clear_default_striping_policy();
  static const int kDefaultStripingPolicyFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::StripingPolicy& default_striping_policy() const;
  inline ::xtreemfs::pbrpc::StripingPolicy* mutable_default_striping_policy();
  
  // required string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required fixed32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);
  
  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string owner_group_id = 6;
  inline bool has_owner_group_id() const;
  inline void clear_owner_group_id();
  static const int kOwnerGroupIdFieldNumber = 6;
  inline const ::std::string& owner_group_id() const;
  inline void set_owner_group_id(const ::std::string& value);
  inline void set_owner_group_id(const char* value);
  inline void set_owner_group_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_group_id();
  
  // required string owner_user_id = 7;
  inline bool has_owner_user_id() const;
  inline void clear_owner_user_id();
  static const int kOwnerUserIdFieldNumber = 7;
  inline const ::std::string& owner_user_id() const;
  inline void set_owner_user_id(const ::std::string& value);
  inline void set_owner_user_id(const char* value);
  inline void set_owner_user_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_user_id();
  
  // repeated .xtreemfs.pbrpc.KeyValuePair attrs = 8;
  inline int attrs_size() const;
  inline void clear_attrs();
  static const int kAttrsFieldNumber = 8;
  inline const ::xtreemfs::pbrpc::KeyValuePair& attrs(int index) const;
  inline ::xtreemfs::pbrpc::KeyValuePair* mutable_attrs(int index);
  inline ::xtreemfs::pbrpc::KeyValuePair* add_attrs();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
      attrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
      mutable_attrs();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Volume)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int access_control_policy_;
  ::xtreemfs::pbrpc::StripingPolicy* default_striping_policy_;
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::uint32 mode_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* owner_group_id_;
  static const ::std::string _default_owner_group_id_;
  ::std::string* owner_user_id_;
  static const ::std::string _default_owner_user_id_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair > attrs_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Volume* default_instance_;
};
// -------------------------------------------------------------------

class Volumes : public ::google::protobuf::Message {
 public:
  Volumes();
  virtual ~Volumes();
  
  Volumes(const Volumes& from);
  
  inline Volumes& operator=(const Volumes& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Volumes& default_instance();
  
  void Swap(Volumes* other);
  
  // implements Message ----------------------------------------------
  
  Volumes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volumes& from);
  void MergeFrom(const Volumes& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .xtreemfs.pbrpc.Volume volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Volume& volumes(int index) const;
  inline ::xtreemfs::pbrpc::Volume* mutable_volumes(int index);
  inline ::xtreemfs::pbrpc::Volume* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >*
      mutable_volumes();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Volumes)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume > volumes_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Volumes* default_instance_;
};
// -------------------------------------------------------------------

class StatVFS : public ::google::protobuf::Message {
 public:
  StatVFS();
  virtual ~StatVFS();
  
  StatVFS(const StatVFS& from);
  
  inline StatVFS& operator=(const StatVFS& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatVFS& default_instance();
  
  void Swap(StatVFS* other);
  
  // implements Message ----------------------------------------------
  
  StatVFS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatVFS& from);
  void MergeFrom(const StatVFS& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 bsize = 1;
  inline bool has_bsize() const;
  inline void clear_bsize();
  static const int kBsizeFieldNumber = 1;
  inline ::google::protobuf::uint32 bsize() const;
  inline void set_bsize(::google::protobuf::uint32 value);
  
  // required fixed64 bavail = 2;
  inline bool has_bavail() const;
  inline void clear_bavail();
  static const int kBavailFieldNumber = 2;
  inline ::google::protobuf::uint64 bavail() const;
  inline void set_bavail(::google::protobuf::uint64 value);
  
  // required fixed64 blocks = 3;
  inline bool has_blocks() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 3;
  inline ::google::protobuf::uint64 blocks() const;
  inline void set_blocks(::google::protobuf::uint64 value);
  
  // required string fsid = 4;
  inline bool has_fsid() const;
  inline void clear_fsid();
  static const int kFsidFieldNumber = 4;
  inline const ::std::string& fsid() const;
  inline void set_fsid(const ::std::string& value);
  inline void set_fsid(const char* value);
  inline void set_fsid(const char* value, size_t size);
  inline ::std::string* mutable_fsid();
  
  // required fixed32 namemax = 5;
  inline bool has_namemax() const;
  inline void clear_namemax();
  static const int kNamemaxFieldNumber = 5;
  inline ::google::protobuf::uint32 namemax() const;
  inline void set_namemax(::google::protobuf::uint32 value);
  
  // required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 6;
  inline bool has_access_control_policy() const;
  inline void clear_access_control_policy();
  static const int kAccessControlPolicyFieldNumber = 6;
  inline xtreemfs::pbrpc::AccessControlPolicyType access_control_policy() const;
  inline void set_access_control_policy(xtreemfs::pbrpc::AccessControlPolicyType value);
  
  // required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 7;
  inline bool has_default_striping_policy() const;
  inline void clear_default_striping_policy();
  static const int kDefaultStripingPolicyFieldNumber = 7;
  inline const ::xtreemfs::pbrpc::StripingPolicy& default_striping_policy() const;
  inline ::xtreemfs::pbrpc::StripingPolicy* mutable_default_striping_policy();
  
  // required fixed64 etag = 8;
  inline bool has_etag() const;
  inline void clear_etag();
  static const int kEtagFieldNumber = 8;
  inline ::google::protobuf::uint64 etag() const;
  inline void set_etag(::google::protobuf::uint64 value);
  
  // required fixed32 mode = 9;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 9;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);
  
  // required string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string owner_group_id = 11;
  inline bool has_owner_group_id() const;
  inline void clear_owner_group_id();
  static const int kOwnerGroupIdFieldNumber = 11;
  inline const ::std::string& owner_group_id() const;
  inline void set_owner_group_id(const ::std::string& value);
  inline void set_owner_group_id(const char* value);
  inline void set_owner_group_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_group_id();
  
  // required string owner_user_id = 12;
  inline bool has_owner_user_id() const;
  inline void clear_owner_user_id();
  static const int kOwnerUserIdFieldNumber = 12;
  inline const ::std::string& owner_user_id() const;
  inline void set_owner_user_id(const ::std::string& value);
  inline void set_owner_user_id(const char* value);
  inline void set_owner_user_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_user_id();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.StatVFS)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 bsize_;
  ::google::protobuf::uint64 bavail_;
  ::google::protobuf::uint64 blocks_;
  ::std::string* fsid_;
  static const ::std::string _default_fsid_;
  ::google::protobuf::uint32 namemax_;
  int access_control_policy_;
  ::xtreemfs::pbrpc::StripingPolicy* default_striping_policy_;
  ::google::protobuf::uint64 etag_;
  ::google::protobuf::uint32 mode_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* owner_group_id_;
  static const ::std::string _default_owner_group_id_;
  ::std::string* owner_user_id_;
  static const ::std::string _default_owner_user_id_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StatVFS* default_instance_;
};
// -------------------------------------------------------------------

class fsetattrRequest : public ::google::protobuf::Message {
 public:
  fsetattrRequest();
  virtual ~fsetattrRequest();
  
  fsetattrRequest(const fsetattrRequest& from);
  
  inline fsetattrRequest& operator=(const fsetattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const fsetattrRequest& default_instance();
  
  void Swap(fsetattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  fsetattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fsetattrRequest& from);
  void MergeFrom(const fsetattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.Stat stbuf = 1;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  
  // required fixed32 to_set = 2;
  inline bool has_to_set() const;
  inline void clear_to_set();
  static const int kToSetFieldNumber = 2;
  inline ::google::protobuf::uint32 to_set() const;
  inline void set_to_set(::google::protobuf::uint32 value);
  
  // required .xtreemfs.pbrpc.XCap cap = 3;
  inline bool has_cap() const;
  inline void clear_cap();
  static const int kCapFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::XCap& cap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_cap();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.fsetattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xtreemfs::pbrpc::Stat* stbuf_;
  ::google::protobuf::uint32 to_set_;
  ::xtreemfs::pbrpc::XCap* cap_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static fsetattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class getattrRequest : public ::google::protobuf::Message {
 public:
  getattrRequest();
  virtual ~getattrRequest();
  
  getattrRequest(const getattrRequest& from);
  
  inline getattrRequest& operator=(const getattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const getattrRequest& default_instance();
  
  void Swap(getattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  getattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getattrRequest& from);
  void MergeFrom(const getattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required fixed64 known_etag = 3;
  inline bool has_known_etag() const;
  inline void clear_known_etag();
  static const int kKnownEtagFieldNumber = 3;
  inline ::google::protobuf::uint64 known_etag() const;
  inline void set_known_etag(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::google::protobuf::uint64 known_etag_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static getattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class getattrResponse : public ::google::protobuf::Message {
 public:
  getattrResponse();
  virtual ~getattrResponse();
  
  getattrResponse(const getattrResponse& from);
  
  inline getattrResponse& operator=(const getattrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const getattrResponse& default_instance();
  
  void Swap(getattrResponse* other);
  
  // implements Message ----------------------------------------------
  
  getattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getattrResponse& from);
  void MergeFrom(const getattrResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .xtreemfs.pbrpc.Stat stbuf = 1;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getattrResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xtreemfs::pbrpc::Stat* stbuf_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static getattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class getxattrRequest : public ::google::protobuf::Message {
 public:
  getxattrRequest();
  virtual ~getxattrRequest();
  
  getxattrRequest(const getxattrRequest& from);
  
  inline getxattrRequest& operator=(const getxattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const getxattrRequest& default_instance();
  
  void Swap(getxattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  getxattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getxattrRequest& from);
  void MergeFrom(const getxattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getxattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static getxattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class getxattrResponse : public ::google::protobuf::Message {
 public:
  getxattrResponse();
  virtual ~getxattrResponse();
  
  getxattrResponse(const getxattrResponse& from);
  
  inline getxattrResponse& operator=(const getxattrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const getxattrResponse& default_instance();
  
  void Swap(getxattrResponse* other);
  
  // implements Message ----------------------------------------------
  
  getxattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getxattrResponse& from);
  void MergeFrom(const getxattrResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getxattrResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static getxattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class linkRequest : public ::google::protobuf::Message {
 public:
  linkRequest();
  virtual ~linkRequest();
  
  linkRequest(const linkRequest& from);
  
  inline linkRequest& operator=(const linkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const linkRequest& default_instance();
  
  void Swap(linkRequest* other);
  
  // implements Message ----------------------------------------------
  
  linkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const linkRequest& from);
  void MergeFrom(const linkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string target_path = 2;
  inline bool has_target_path() const;
  inline void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  inline const ::std::string& target_path() const;
  inline void set_target_path(const ::std::string& value);
  inline void set_target_path(const char* value);
  inline void set_target_path(const char* value, size_t size);
  inline ::std::string* mutable_target_path();
  
  // required string link_path = 3;
  inline bool has_link_path() const;
  inline void clear_link_path();
  static const int kLinkPathFieldNumber = 3;
  inline const ::std::string& link_path() const;
  inline void set_link_path(const ::std::string& value);
  inline void set_link_path(const char* value);
  inline void set_link_path(const char* value, size_t size);
  inline ::std::string* mutable_link_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.linkRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* target_path_;
  static const ::std::string _default_target_path_;
  ::std::string* link_path_;
  static const ::std::string _default_link_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static linkRequest* default_instance_;
};
// -------------------------------------------------------------------

class listxattrRequest : public ::google::protobuf::Message {
 public:
  listxattrRequest();
  virtual ~listxattrRequest();
  
  listxattrRequest(const listxattrRequest& from);
  
  inline listxattrRequest& operator=(const listxattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const listxattrRequest& default_instance();
  
  void Swap(listxattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  listxattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const listxattrRequest& from);
  void MergeFrom(const listxattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required bool names_only = 3;
  inline bool has_names_only() const;
  inline void clear_names_only();
  static const int kNamesOnlyFieldNumber = 3;
  inline bool names_only() const;
  inline void set_names_only(bool value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.listxattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  bool names_only_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static listxattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class listxattrResponse : public ::google::protobuf::Message {
 public:
  listxattrResponse();
  virtual ~listxattrResponse();
  
  listxattrResponse(const listxattrResponse& from);
  
  inline listxattrResponse& operator=(const listxattrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const listxattrResponse& default_instance();
  
  void Swap(listxattrResponse* other);
  
  // implements Message ----------------------------------------------
  
  listxattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const listxattrResponse& from);
  void MergeFrom(const listxattrResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .xtreemfs.pbrpc.XAttr xattrs = 1;
  inline int xattrs_size() const;
  inline void clear_xattrs();
  static const int kXattrsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::XAttr& xattrs(int index) const;
  inline ::xtreemfs::pbrpc::XAttr* mutable_xattrs(int index);
  inline ::xtreemfs::pbrpc::XAttr* add_xattrs();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >&
      xattrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >*
      mutable_xattrs();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.listxattrResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr > xattrs_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static listxattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class mkdirRequest : public ::google::protobuf::Message {
 public:
  mkdirRequest();
  virtual ~mkdirRequest();
  
  mkdirRequest(const mkdirRequest& from);
  
  inline mkdirRequest& operator=(const mkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const mkdirRequest& default_instance();
  
  void Swap(mkdirRequest* other);
  
  // implements Message ----------------------------------------------
  
  mkdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mkdirRequest& from);
  void MergeFrom(const mkdirRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required fixed32 mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.mkdirRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::google::protobuf::uint32 mode_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static mkdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class openRequest : public ::google::protobuf::Message {
 public:
  openRequest();
  virtual ~openRequest();
  
  openRequest(const openRequest& from);
  
  inline openRequest& operator=(const openRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const openRequest& default_instance();
  
  void Swap(openRequest* other);
  
  // implements Message ----------------------------------------------
  
  openRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const openRequest& from);
  void MergeFrom(const openRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required fixed32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // required fixed32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);
  
  // required fixed32 attributes = 5;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline ::google::protobuf::uint32 attributes() const;
  inline void set_attributes(::google::protobuf::uint32 value);
  
  // optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 6;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 6;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.openRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 mode_;
  ::google::protobuf::uint32 attributes_;
  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static openRequest* default_instance_;
};
// -------------------------------------------------------------------

class openResponse : public ::google::protobuf::Message {
 public:
  openResponse();
  virtual ~openResponse();
  
  openResponse(const openResponse& from);
  
  inline openResponse& operator=(const openResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const openResponse& default_instance();
  
  void Swap(openResponse* other);
  
  // implements Message ----------------------------------------------
  
  openResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const openResponse& from);
  void MergeFrom(const openResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.FileCredentials creds = 1;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& creds() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_creds();
  
  // required fixed32 timestamp_s = 2;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 2;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.openResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xtreemfs::pbrpc::FileCredentials* creds_;
  ::google::protobuf::uint32 timestamp_s_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static openResponse* default_instance_;
};
// -------------------------------------------------------------------

class readdirRequest : public ::google::protobuf::Message {
 public:
  readdirRequest();
  virtual ~readdirRequest();
  
  readdirRequest(const readdirRequest& from);
  
  inline readdirRequest& operator=(const readdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const readdirRequest& default_instance();
  
  void Swap(readdirRequest* other);
  
  // implements Message ----------------------------------------------
  
  readdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readdirRequest& from);
  void MergeFrom(const readdirRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required fixed64 known_etag = 3;
  inline bool has_known_etag() const;
  inline void clear_known_etag();
  static const int kKnownEtagFieldNumber = 3;
  inline ::google::protobuf::uint64 known_etag() const;
  inline void set_known_etag(::google::protobuf::uint64 value);
  
  // required fixed32 limit_directory_entries_count = 4;
  inline bool has_limit_directory_entries_count() const;
  inline void clear_limit_directory_entries_count();
  static const int kLimitDirectoryEntriesCountFieldNumber = 4;
  inline ::google::protobuf::uint32 limit_directory_entries_count() const;
  inline void set_limit_directory_entries_count(::google::protobuf::uint32 value);
  
  // required bool names_only = 5;
  inline bool has_names_only() const;
  inline void clear_names_only();
  static const int kNamesOnlyFieldNumber = 5;
  inline bool names_only() const;
  inline void set_names_only(bool value);
  
  // required fixed64 seen_directory_entries_count = 6;
  inline bool has_seen_directory_entries_count() const;
  inline void clear_seen_directory_entries_count();
  static const int kSeenDirectoryEntriesCountFieldNumber = 6;
  inline ::google::protobuf::uint64 seen_directory_entries_count() const;
  inline void set_seen_directory_entries_count(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readdirRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::google::protobuf::uint64 known_etag_;
  ::google::protobuf::uint32 limit_directory_entries_count_;
  bool names_only_;
  ::google::protobuf::uint64 seen_directory_entries_count_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static readdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class readlinkRequest : public ::google::protobuf::Message {
 public:
  readlinkRequest();
  virtual ~readlinkRequest();
  
  readlinkRequest(const readlinkRequest& from);
  
  inline readlinkRequest& operator=(const readlinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const readlinkRequest& default_instance();
  
  void Swap(readlinkRequest* other);
  
  // implements Message ----------------------------------------------
  
  readlinkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readlinkRequest& from);
  void MergeFrom(const readlinkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readlinkRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static readlinkRequest* default_instance_;
};
// -------------------------------------------------------------------

class readlinkResponse : public ::google::protobuf::Message {
 public:
  readlinkResponse();
  virtual ~readlinkResponse();
  
  readlinkResponse(const readlinkResponse& from);
  
  inline readlinkResponse& operator=(const readlinkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const readlinkResponse& default_instance();
  
  void Swap(readlinkResponse* other);
  
  // implements Message ----------------------------------------------
  
  readlinkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readlinkResponse& from);
  void MergeFrom(const readlinkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string link_target_path = 1;
  inline int link_target_path_size() const;
  inline void clear_link_target_path();
  static const int kLinkTargetPathFieldNumber = 1;
  inline const ::std::string& link_target_path(int index) const;
  inline ::std::string* mutable_link_target_path(int index);
  inline void set_link_target_path(int index, const ::std::string& value);
  inline void set_link_target_path(int index, const char* value);
  inline void set_link_target_path(int index, const char* value, size_t size);
  inline ::std::string* add_link_target_path();
  inline void add_link_target_path(const ::std::string& value);
  inline void add_link_target_path(const char* value);
  inline void add_link_target_path(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& link_target_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_target_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readlinkResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> link_target_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static readlinkResponse* default_instance_;
};
// -------------------------------------------------------------------

class removexattrRequest : public ::google::protobuf::Message {
 public:
  removexattrRequest();
  virtual ~removexattrRequest();
  
  removexattrRequest(const removexattrRequest& from);
  
  inline removexattrRequest& operator=(const removexattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const removexattrRequest& default_instance();
  
  void Swap(removexattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  removexattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const removexattrRequest& from);
  void MergeFrom(const removexattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.removexattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static removexattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class renameRequest : public ::google::protobuf::Message {
 public:
  renameRequest();
  virtual ~renameRequest();
  
  renameRequest(const renameRequest& from);
  
  inline renameRequest& operator=(const renameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const renameRequest& default_instance();
  
  void Swap(renameRequest* other);
  
  // implements Message ----------------------------------------------
  
  renameRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const renameRequest& from);
  void MergeFrom(const renameRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string source_path = 2;
  inline bool has_source_path() const;
  inline void clear_source_path();
  static const int kSourcePathFieldNumber = 2;
  inline const ::std::string& source_path() const;
  inline void set_source_path(const ::std::string& value);
  inline void set_source_path(const char* value);
  inline void set_source_path(const char* value, size_t size);
  inline ::std::string* mutable_source_path();
  
  // required string target_path = 3;
  inline bool has_target_path() const;
  inline void clear_target_path();
  static const int kTargetPathFieldNumber = 3;
  inline const ::std::string& target_path() const;
  inline void set_target_path(const ::std::string& value);
  inline void set_target_path(const char* value);
  inline void set_target_path(const char* value, size_t size);
  inline ::std::string* mutable_target_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.renameRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* source_path_;
  static const ::std::string _default_source_path_;
  ::std::string* target_path_;
  static const ::std::string _default_target_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static renameRequest* default_instance_;
};
// -------------------------------------------------------------------

class renameResponse : public ::google::protobuf::Message {
 public:
  renameResponse();
  virtual ~renameResponse();
  
  renameResponse(const renameResponse& from);
  
  inline renameResponse& operator=(const renameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const renameResponse& default_instance();
  
  void Swap(renameResponse* other);
  
  // implements Message ----------------------------------------------
  
  renameResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const renameResponse& from);
  void MergeFrom(const renameResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 timestamp_s = 1;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);
  
  // optional .xtreemfs.pbrpc.FileCredentials creds = 2;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::FileCredentials& creds() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_creds();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.renameResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 timestamp_s_;
  ::xtreemfs::pbrpc::FileCredentials* creds_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static renameResponse* default_instance_;
};
// -------------------------------------------------------------------

class rmdirRequest : public ::google::protobuf::Message {
 public:
  rmdirRequest();
  virtual ~rmdirRequest();
  
  rmdirRequest(const rmdirRequest& from);
  
  inline rmdirRequest& operator=(const rmdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const rmdirRequest& default_instance();
  
  void Swap(rmdirRequest* other);
  
  // implements Message ----------------------------------------------
  
  rmdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rmdirRequest& from);
  void MergeFrom(const rmdirRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.rmdirRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static rmdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class setattrRequest : public ::google::protobuf::Message {
 public:
  setattrRequest();
  virtual ~setattrRequest();
  
  setattrRequest(const setattrRequest& from);
  
  inline setattrRequest& operator=(const setattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const setattrRequest& default_instance();
  
  void Swap(setattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  setattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const setattrRequest& from);
  void MergeFrom(const setattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required .xtreemfs.pbrpc.Stat stbuf = 3;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  
  // required fixed32 to_set = 4;
  inline bool has_to_set() const;
  inline void clear_to_set();
  static const int kToSetFieldNumber = 4;
  inline ::google::protobuf::uint32 to_set() const;
  inline void set_to_set(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.setattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::xtreemfs::pbrpc::Stat* stbuf_;
  ::google::protobuf::uint32 to_set_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static setattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class setxattrRequest : public ::google::protobuf::Message {
 public:
  setxattrRequest();
  virtual ~setxattrRequest();
  
  setxattrRequest(const setxattrRequest& from);
  
  inline setxattrRequest& operator=(const setxattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const setxattrRequest& default_instance();
  
  void Swap(setxattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  setxattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const setxattrRequest& from);
  void MergeFrom(const setxattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // required fixed32 flags = 5;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 5;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.setxattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::google::protobuf::uint32 flags_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static setxattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class statvfsRequest : public ::google::protobuf::Message {
 public:
  statvfsRequest();
  virtual ~statvfsRequest();
  
  statvfsRequest(const statvfsRequest& from);
  
  inline statvfsRequest& operator=(const statvfsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const statvfsRequest& default_instance();
  
  void Swap(statvfsRequest* other);
  
  // implements Message ----------------------------------------------
  
  statvfsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statvfsRequest& from);
  void MergeFrom(const statvfsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required fixed64 known_etag = 5;
  inline bool has_known_etag() const;
  inline void clear_known_etag();
  static const int kKnownEtagFieldNumber = 5;
  inline ::google::protobuf::uint64 known_etag() const;
  inline void set_known_etag(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.statvfsRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::google::protobuf::uint64 known_etag_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static statvfsRequest* default_instance_;
};
// -------------------------------------------------------------------

class symlinkRequest : public ::google::protobuf::Message {
 public:
  symlinkRequest();
  virtual ~symlinkRequest();
  
  symlinkRequest(const symlinkRequest& from);
  
  inline symlinkRequest& operator=(const symlinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const symlinkRequest& default_instance();
  
  void Swap(symlinkRequest* other);
  
  // implements Message ----------------------------------------------
  
  symlinkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const symlinkRequest& from);
  void MergeFrom(const symlinkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string target_path = 2;
  inline bool has_target_path() const;
  inline void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  inline const ::std::string& target_path() const;
  inline void set_target_path(const ::std::string& value);
  inline void set_target_path(const char* value);
  inline void set_target_path(const char* value, size_t size);
  inline ::std::string* mutable_target_path();
  
  // required string link_path = 3;
  inline bool has_link_path() const;
  inline void clear_link_path();
  static const int kLinkPathFieldNumber = 3;
  inline const ::std::string& link_path() const;
  inline void set_link_path(const ::std::string& value);
  inline void set_link_path(const char* value);
  inline void set_link_path(const char* value, size_t size);
  inline ::std::string* mutable_link_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.symlinkRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* target_path_;
  static const ::std::string _default_target_path_;
  ::std::string* link_path_;
  static const ::std::string _default_link_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static symlinkRequest* default_instance_;
};
// -------------------------------------------------------------------

class unlinkRequest : public ::google::protobuf::Message {
 public:
  unlinkRequest();
  virtual ~unlinkRequest();
  
  unlinkRequest(const unlinkRequest& from);
  
  inline unlinkRequest& operator=(const unlinkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const unlinkRequest& default_instance();
  
  void Swap(unlinkRequest* other);
  
  // implements Message ----------------------------------------------
  
  unlinkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unlinkRequest& from);
  void MergeFrom(const unlinkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.unlinkRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static unlinkRequest* default_instance_;
};
// -------------------------------------------------------------------

class unlinkResponse : public ::google::protobuf::Message {
 public:
  unlinkResponse();
  virtual ~unlinkResponse();
  
  unlinkResponse(const unlinkResponse& from);
  
  inline unlinkResponse& operator=(const unlinkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const unlinkResponse& default_instance();
  
  void Swap(unlinkResponse* other);
  
  // implements Message ----------------------------------------------
  
  unlinkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unlinkResponse& from);
  void MergeFrom(const unlinkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 timestamp_s = 1;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);
  
  // optional .xtreemfs.pbrpc.FileCredentials creds = 2;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::FileCredentials& creds() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_creds();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.unlinkResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 timestamp_s_;
  ::xtreemfs::pbrpc::FileCredentials* creds_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static unlinkResponse* default_instance_;
};
// -------------------------------------------------------------------

class accessRequest : public ::google::protobuf::Message {
 public:
  accessRequest();
  virtual ~accessRequest();
  
  accessRequest(const accessRequest& from);
  
  inline accessRequest& operator=(const accessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const accessRequest& default_instance();
  
  void Swap(accessRequest* other);
  
  // implements Message ----------------------------------------------
  
  accessRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const accessRequest& from);
  void MergeFrom(const accessRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // required fixed32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.accessRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::google::protobuf::uint32 flags_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static accessRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_check_file_existsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_check_file_existsRequest();
  virtual ~xtreemfs_check_file_existsRequest();
  
  xtreemfs_check_file_existsRequest(const xtreemfs_check_file_existsRequest& from);
  
  inline xtreemfs_check_file_existsRequest& operator=(const xtreemfs_check_file_existsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_check_file_existsRequest& default_instance();
  
  void Swap(xtreemfs_check_file_existsRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_check_file_existsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_check_file_existsRequest& from);
  void MergeFrom(const xtreemfs_check_file_existsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_id = 1;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 1;
  inline const ::std::string& volume_id() const;
  inline void set_volume_id(const ::std::string& value);
  inline void set_volume_id(const char* value);
  inline void set_volume_id(const char* value, size_t size);
  inline ::std::string* mutable_volume_id();
  
  // repeated string file_ids = 2;
  inline int file_ids_size() const;
  inline void clear_file_ids();
  static const int kFileIdsFieldNumber = 2;
  inline const ::std::string& file_ids(int index) const;
  inline ::std::string* mutable_file_ids(int index);
  inline void set_file_ids(int index, const ::std::string& value);
  inline void set_file_ids(int index, const char* value);
  inline void set_file_ids(int index, const char* value, size_t size);
  inline ::std::string* add_file_ids();
  inline void add_file_ids(const ::std::string& value);
  inline void add_file_ids(const char* value);
  inline void add_file_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& file_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file_ids();
  
  // required string osd_uuid = 3;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 3;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_check_file_existsRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_id_;
  static const ::std::string _default_volume_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> file_ids_;
  ::std::string* osd_uuid_;
  static const ::std::string _default_osd_uuid_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_check_file_existsRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_dump_restore_databaseRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_dump_restore_databaseRequest();
  virtual ~xtreemfs_dump_restore_databaseRequest();
  
  xtreemfs_dump_restore_databaseRequest(const xtreemfs_dump_restore_databaseRequest& from);
  
  inline xtreemfs_dump_restore_databaseRequest& operator=(const xtreemfs_dump_restore_databaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_dump_restore_databaseRequest& default_instance();
  
  void Swap(xtreemfs_dump_restore_databaseRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_dump_restore_databaseRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_dump_restore_databaseRequest& from);
  void MergeFrom(const xtreemfs_dump_restore_databaseRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string dump_file = 1;
  inline bool has_dump_file() const;
  inline void clear_dump_file();
  static const int kDumpFileFieldNumber = 1;
  inline const ::std::string& dump_file() const;
  inline void set_dump_file(const ::std::string& value);
  inline void set_dump_file(const char* value);
  inline void set_dump_file(const char* value, size_t size);
  inline ::std::string* mutable_dump_file();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_dump_restore_databaseRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* dump_file_;
  static const ::std::string _default_dump_file_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_dump_restore_databaseRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_suitable_osdsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_get_suitable_osdsRequest();
  virtual ~xtreemfs_get_suitable_osdsRequest();
  
  xtreemfs_get_suitable_osdsRequest(const xtreemfs_get_suitable_osdsRequest& from);
  
  inline xtreemfs_get_suitable_osdsRequest& operator=(const xtreemfs_get_suitable_osdsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_suitable_osdsRequest& default_instance();
  
  void Swap(xtreemfs_get_suitable_osdsRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_get_suitable_osdsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_suitable_osdsRequest& from);
  void MergeFrom(const xtreemfs_get_suitable_osdsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // optional string volume_name = 4;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 4;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required fixed32 num_osds = 2;
  inline bool has_num_osds() const;
  inline void clear_num_osds();
  static const int kNumOsdsFieldNumber = 2;
  inline ::google::protobuf::uint32 num_osds() const;
  inline void set_num_osds(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_suitable_osdsRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::google::protobuf::uint32 num_osds_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_get_suitable_osdsRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_suitable_osdsResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_get_suitable_osdsResponse();
  virtual ~xtreemfs_get_suitable_osdsResponse();
  
  xtreemfs_get_suitable_osdsResponse(const xtreemfs_get_suitable_osdsResponse& from);
  
  inline xtreemfs_get_suitable_osdsResponse& operator=(const xtreemfs_get_suitable_osdsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_suitable_osdsResponse& default_instance();
  
  void Swap(xtreemfs_get_suitable_osdsResponse* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_get_suitable_osdsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_suitable_osdsResponse& from);
  void MergeFrom(const xtreemfs_get_suitable_osdsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string osd_uuids = 1;
  inline int osd_uuids_size() const;
  inline void clear_osd_uuids();
  static const int kOsdUuidsFieldNumber = 1;
  inline const ::std::string& osd_uuids(int index) const;
  inline ::std::string* mutable_osd_uuids(int index);
  inline void set_osd_uuids(int index, const ::std::string& value);
  inline void set_osd_uuids(int index, const char* value);
  inline void set_osd_uuids(int index, const char* value, size_t size);
  inline ::std::string* add_osd_uuids();
  inline void add_osd_uuids(const ::std::string& value);
  inline void add_osd_uuids(const char* value);
  inline void add_osd_uuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& osd_uuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_osd_uuids();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_suitable_osdsResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> osd_uuids_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_get_suitable_osdsResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_check_file_existsResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_check_file_existsResponse();
  virtual ~xtreemfs_check_file_existsResponse();
  
  xtreemfs_check_file_existsResponse(const xtreemfs_check_file_existsResponse& from);
  
  inline xtreemfs_check_file_existsResponse& operator=(const xtreemfs_check_file_existsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_check_file_existsResponse& default_instance();
  
  void Swap(xtreemfs_check_file_existsResponse* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_check_file_existsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_check_file_existsResponse& from);
  void MergeFrom(const xtreemfs_check_file_existsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string bitmap = 1;
  inline bool has_bitmap() const;
  inline void clear_bitmap();
  static const int kBitmapFieldNumber = 1;
  inline const ::std::string& bitmap() const;
  inline void set_bitmap(const ::std::string& value);
  inline void set_bitmap(const char* value);
  inline void set_bitmap(const char* value, size_t size);
  inline ::std::string* mutable_bitmap();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_check_file_existsResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bitmap_;
  static const ::std::string _default_bitmap_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_check_file_existsResponse* default_instance_;
};
// -------------------------------------------------------------------

class timestampResponse : public ::google::protobuf::Message {
 public:
  timestampResponse();
  virtual ~timestampResponse();
  
  timestampResponse(const timestampResponse& from);
  
  inline timestampResponse& operator=(const timestampResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const timestampResponse& default_instance();
  
  void Swap(timestampResponse* other);
  
  // implements Message ----------------------------------------------
  
  timestampResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const timestampResponse& from);
  void MergeFrom(const timestampResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required fixed32 timestamp_s = 1;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.timestampResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 timestamp_s_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static timestampResponse* default_instance_;
};
// -------------------------------------------------------------------

class stringMessage : public ::google::protobuf::Message {
 public:
  stringMessage();
  virtual ~stringMessage();
  
  stringMessage(const stringMessage& from);
  
  inline stringMessage& operator=(const stringMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const stringMessage& default_instance();
  
  void Swap(stringMessage* other);
  
  // implements Message ----------------------------------------------
  
  stringMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stringMessage& from);
  void MergeFrom(const stringMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string a_string = 1;
  inline bool has_a_string() const;
  inline void clear_a_string();
  static const int kAStringFieldNumber = 1;
  inline const ::std::string& a_string() const;
  inline void set_a_string(const ::std::string& value);
  inline void set_a_string(const char* value);
  inline void set_a_string(const char* value, size_t size);
  inline ::std::string* mutable_a_string();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.stringMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* a_string_;
  static const ::std::string _default_a_string_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static stringMessage* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_listdirRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_listdirRequest();
  virtual ~xtreemfs_listdirRequest();
  
  xtreemfs_listdirRequest(const xtreemfs_listdirRequest& from);
  
  inline xtreemfs_listdirRequest& operator=(const xtreemfs_listdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_listdirRequest& default_instance();
  
  void Swap(xtreemfs_listdirRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_listdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_listdirRequest& from);
  void MergeFrom(const xtreemfs_listdirRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_listdirRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* path_;
  static const ::std::string _default_path_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_listdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_listdirResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_listdirResponse();
  virtual ~xtreemfs_listdirResponse();
  
  xtreemfs_listdirResponse(const xtreemfs_listdirResponse& from);
  
  inline xtreemfs_listdirResponse& operator=(const xtreemfs_listdirResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_listdirResponse& default_instance();
  
  void Swap(xtreemfs_listdirResponse* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_listdirResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_listdirResponse& from);
  void MergeFrom(const xtreemfs_listdirResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_listdirResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_listdirResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_addRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_addRequest();
  virtual ~xtreemfs_replica_addRequest();
  
  xtreemfs_replica_addRequest(const xtreemfs_replica_addRequest& from);
  
  inline xtreemfs_replica_addRequest& operator=(const xtreemfs_replica_addRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_addRequest& default_instance();
  
  void Swap(xtreemfs_replica_addRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_replica_addRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_addRequest& from);
  void MergeFrom(const xtreemfs_replica_addRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // optional string volume_name = 4;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 4;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required .xtreemfs.pbrpc.Replica new_replica = 2;
  inline bool has_new_replica() const;
  inline void clear_new_replica();
  static const int kNewReplicaFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::Replica& new_replica() const;
  inline ::xtreemfs::pbrpc::Replica* mutable_new_replica();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_addRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::xtreemfs::pbrpc::Replica* new_replica_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_replica_addRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_listRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_listRequest();
  virtual ~xtreemfs_replica_listRequest();
  
  xtreemfs_replica_listRequest(const xtreemfs_replica_listRequest& from);
  
  inline xtreemfs_replica_listRequest& operator=(const xtreemfs_replica_listRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_listRequest& default_instance();
  
  void Swap(xtreemfs_replica_listRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_replica_listRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_listRequest& from);
  void MergeFrom(const xtreemfs_replica_listRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // optional string volume_name = 3;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 3;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_listRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_replica_listRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_removeRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_removeRequest();
  virtual ~xtreemfs_replica_removeRequest();
  
  xtreemfs_replica_removeRequest(const xtreemfs_replica_removeRequest& from);
  
  inline xtreemfs_replica_removeRequest& operator=(const xtreemfs_replica_removeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_removeRequest& default_instance();
  
  void Swap(xtreemfs_replica_removeRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_replica_removeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_removeRequest& from);
  void MergeFrom(const xtreemfs_replica_removeRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  
  // optional string volume_name = 4;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 4;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // required string osd_uuid = 2;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 2;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_removeRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  ::std::string* path_;
  static const ::std::string _default_path_;
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  ::std::string* osd_uuid_;
  static const ::std::string _default_osd_uuid_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_replica_removeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_restore_fileRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_restore_fileRequest();
  virtual ~xtreemfs_restore_fileRequest();
  
  xtreemfs_restore_fileRequest(const xtreemfs_restore_fileRequest& from);
  
  inline xtreemfs_restore_fileRequest& operator=(const xtreemfs_restore_fileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_restore_fileRequest& default_instance();
  
  void Swap(xtreemfs_restore_fileRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_restore_fileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_restore_fileRequest& from);
  void MergeFrom(const xtreemfs_restore_fileRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  
  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // required fixed64 file_size = 3;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 file_size() const;
  inline void set_file_size(::google::protobuf::uint64 value);
  
  // required string osd_uuid = 4;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 4;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  
  // required fixed32 stripe_size = 5;
  inline bool has_stripe_size() const;
  inline void clear_stripe_size();
  static const int kStripeSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 stripe_size() const;
  inline void set_stripe_size(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_restore_fileRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_path_;
  static const ::std::string _default_file_path_;
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  ::google::protobuf::uint64 file_size_;
  ::std::string* osd_uuid_;
  static const ::std::string _default_osd_uuid_;
  ::google::protobuf::uint32 stripe_size_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_restore_fileRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rmvolRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rmvolRequest();
  virtual ~xtreemfs_rmvolRequest();
  
  xtreemfs_rmvolRequest(const xtreemfs_rmvolRequest& from);
  
  inline xtreemfs_rmvolRequest& operator=(const xtreemfs_rmvolRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rmvolRequest& default_instance();
  
  void Swap(xtreemfs_rmvolRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_rmvolRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rmvolRequest& from);
  void MergeFrom(const xtreemfs_rmvolRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rmvolRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* volume_name_;
  static const ::std::string _default_volume_name_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_rmvolRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_update_file_sizeRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_update_file_sizeRequest();
  virtual ~xtreemfs_update_file_sizeRequest();
  
  xtreemfs_update_file_sizeRequest(const xtreemfs_update_file_sizeRequest& from);
  
  inline xtreemfs_update_file_sizeRequest& operator=(const xtreemfs_update_file_sizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_update_file_sizeRequest& default_instance();
  
  void Swap(xtreemfs_update_file_sizeRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_update_file_sizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_update_file_sizeRequest& from);
  void MergeFrom(const xtreemfs_update_file_sizeRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xtreemfs.pbrpc.XCap xcap = 1;
  inline bool has_xcap() const;
  inline void clear_xcap();
  static const int kXcapFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::XCap& xcap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_xcap();
  
  // required .xtreemfs.pbrpc.OSDWriteResponse osd_write_response = 2;
  inline bool has_osd_write_response() const;
  inline void clear_osd_write_response();
  static const int kOsdWriteResponseFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::OSDWriteResponse& osd_write_response() const;
  inline ::xtreemfs::pbrpc::OSDWriteResponse* mutable_osd_write_response();
  
  // optional bool close_file = 3;
  inline bool has_close_file() const;
  inline void clear_close_file();
  static const int kCloseFileFieldNumber = 3;
  inline bool close_file() const;
  inline void set_close_file(bool value);
  
  // optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 4;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_update_file_sizeRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::xtreemfs::pbrpc::XCap* xcap_;
  ::xtreemfs::pbrpc::OSDWriteResponse* osd_write_response_;
  bool close_file_;
  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_update_file_sizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_replica_update_policyRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_set_replica_update_policyRequest();
  virtual ~xtreemfs_set_replica_update_policyRequest();
  
  xtreemfs_set_replica_update_policyRequest(const xtreemfs_set_replica_update_policyRequest& from);
  
  inline xtreemfs_set_replica_update_policyRequest& operator=(const xtreemfs_set_replica_update_policyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_replica_update_policyRequest& default_instance();
  
  void Swap(xtreemfs_set_replica_update_policyRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_set_replica_update_policyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_replica_update_policyRequest& from);
  void MergeFrom(const xtreemfs_set_replica_update_policyRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // required string update_policy = 2;
  inline bool has_update_policy() const;
  inline void clear_update_policy();
  static const int kUpdatePolicyFieldNumber = 2;
  inline const ::std::string& update_policy() const;
  inline void set_update_policy(const ::std::string& value);
  inline void set_update_policy(const char* value);
  inline void set_update_policy(const char* value, size_t size);
  inline ::std::string* mutable_update_policy();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_replica_update_policyRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  ::std::string* update_policy_;
  static const ::std::string _default_update_policy_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_set_replica_update_policyRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_replica_update_policyResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_set_replica_update_policyResponse();
  virtual ~xtreemfs_set_replica_update_policyResponse();
  
  xtreemfs_set_replica_update_policyResponse(const xtreemfs_set_replica_update_policyResponse& from);
  
  inline xtreemfs_set_replica_update_policyResponse& operator=(const xtreemfs_set_replica_update_policyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_replica_update_policyResponse& default_instance();
  
  void Swap(xtreemfs_set_replica_update_policyResponse* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_set_replica_update_policyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_replica_update_policyResponse& from);
  void MergeFrom(const xtreemfs_set_replica_update_policyResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string old_update_policy = 1;
  inline bool has_old_update_policy() const;
  inline void clear_old_update_policy();
  static const int kOldUpdatePolicyFieldNumber = 1;
  inline const ::std::string& old_update_policy() const;
  inline void set_old_update_policy(const ::std::string& value);
  inline void set_old_update_policy(const char* value);
  inline void set_old_update_policy(const char* value, size_t size);
  inline ::std::string* mutable_old_update_policy();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_replica_update_policyResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* old_update_policy_;
  static const ::std::string _default_old_update_policy_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_set_replica_update_policyResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_read_only_xattrRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_set_read_only_xattrRequest();
  virtual ~xtreemfs_set_read_only_xattrRequest();
  
  xtreemfs_set_read_only_xattrRequest(const xtreemfs_set_read_only_xattrRequest& from);
  
  inline xtreemfs_set_read_only_xattrRequest& operator=(const xtreemfs_set_read_only_xattrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_read_only_xattrRequest& default_instance();
  
  void Swap(xtreemfs_set_read_only_xattrRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_set_read_only_xattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_read_only_xattrRequest& from);
  void MergeFrom(const xtreemfs_set_read_only_xattrRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // required bool value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline bool value() const;
  inline void set_value(bool value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_read_only_xattrRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  bool value_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_set_read_only_xattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_read_only_xattrResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_set_read_only_xattrResponse();
  virtual ~xtreemfs_set_read_only_xattrResponse();
  
  xtreemfs_set_read_only_xattrResponse(const xtreemfs_set_read_only_xattrResponse& from);
  
  inline xtreemfs_set_read_only_xattrResponse& operator=(const xtreemfs_set_read_only_xattrResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_read_only_xattrResponse& default_instance();
  
  void Swap(xtreemfs_set_read_only_xattrResponse* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_set_read_only_xattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_read_only_xattrResponse& from);
  void MergeFrom(const xtreemfs_set_read_only_xattrResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool was_set = 1;
  inline bool has_was_set() const;
  inline void clear_was_set();
  static const int kWasSetFieldNumber = 1;
  inline bool was_set() const;
  inline void set_was_set(bool value);
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_read_only_xattrResponse)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool was_set_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_set_read_only_xattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_file_credentialsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_get_file_credentialsRequest();
  virtual ~xtreemfs_get_file_credentialsRequest();
  
  xtreemfs_get_file_credentialsRequest(const xtreemfs_get_file_credentialsRequest& from);
  
  inline xtreemfs_get_file_credentialsRequest& operator=(const xtreemfs_get_file_credentialsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_file_credentialsRequest& default_instance();
  
  void Swap(xtreemfs_get_file_credentialsRequest* other);
  
  // implements Message ----------------------------------------------
  
  xtreemfs_get_file_credentialsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_file_credentialsRequest& from);
  void MergeFrom(const xtreemfs_get_file_credentialsRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  
  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_file_credentialsRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_id_;
  static const ::std::string _default_file_id_;
  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static xtreemfs_get_file_credentialsRequest* default_instance_;
};
// ===================================================================

class MRCService_Stub;

class MRCService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MRCService() {};
 public:
  virtual ~MRCService();
  
  typedef MRCService_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void fsetattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::fsetattrRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void ftruncate(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::XCap* request,
                       ::xtreemfs::pbrpc::XCap* response,
                       ::google::protobuf::Closure* done);
  virtual void getattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::getattrRequest* request,
                       ::xtreemfs::pbrpc::getattrResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void getxattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::getxattrRequest* request,
                       ::xtreemfs::pbrpc::getxattrResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void link(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::linkRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void listxattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::listxattrRequest* request,
                       ::xtreemfs::pbrpc::listxattrResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void mkdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::mkdirRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void open(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::openRequest* request,
                       ::xtreemfs::pbrpc::openResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void readdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::readdirRequest* request,
                       ::xtreemfs::pbrpc::DirectoryEntries* response,
                       ::google::protobuf::Closure* done);
  virtual void readlink(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::readlinkRequest* request,
                       ::xtreemfs::pbrpc::readlinkResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void removexattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::removexattrRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void rename(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::renameRequest* request,
                       ::xtreemfs::pbrpc::renameResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void rmdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::rmdirRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void setattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::setattrRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void setxattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::setxattrRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void statvfs(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::statvfsRequest* request,
                       ::xtreemfs::pbrpc::StatVFS* response,
                       ::google::protobuf::Closure* done);
  virtual void symlink(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::symlinkRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void unlink(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::unlinkRequest* request,
                       ::xtreemfs::pbrpc::unlinkResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void access(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::accessRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_checkpoint(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_check_file_exists(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_check_file_existsRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_dump_database(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_dump_restore_databaseRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_get_suitable_osds(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_get_suitable_osdsRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_get_suitable_osdsResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_internal_debug(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::stringMessage* request,
                       ::xtreemfs::pbrpc::stringMessage* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_listdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_listdirRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_listdirResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_lsvol(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::Volumes* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_mkvol(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::Volume* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_renew_capability(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::XCap* request,
                       ::xtreemfs::pbrpc::XCap* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_replication_to_master(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_replica_add(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_replica_addRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_replica_list(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_replica_listRequest* request,
                       ::xtreemfs::pbrpc::Replicas* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_replica_remove(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_replica_removeRequest* request,
                       ::xtreemfs::pbrpc::FileCredentials* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_restore_database(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_dump_restore_databaseRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_restore_file(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_restore_fileRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_rmvol(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_rmvolRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_shutdown(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_update_file_size(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_update_file_sizeRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_set_replica_update_policy(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_set_replica_update_policyRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_set_replica_update_policyResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_set_read_only_xattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_set_read_only_xattrRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_set_read_only_xattrResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void xtreemfs_get_file_credentials(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_get_file_credentialsRequest* request,
                       ::xtreemfs::pbrpc::FileCredentials* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MRCService);
};

class MRCService_Stub : public MRCService {
 public:
  MRCService_Stub(::google::protobuf::RpcChannel* channel);
  MRCService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~MRCService_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements MRCService ------------------------------------------
  
  void fsetattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::fsetattrRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void ftruncate(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::XCap* request,
                       ::xtreemfs::pbrpc::XCap* response,
                       ::google::protobuf::Closure* done);
  void getattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::getattrRequest* request,
                       ::xtreemfs::pbrpc::getattrResponse* response,
                       ::google::protobuf::Closure* done);
  void getxattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::getxattrRequest* request,
                       ::xtreemfs::pbrpc::getxattrResponse* response,
                       ::google::protobuf::Closure* done);
  void link(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::linkRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void listxattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::listxattrRequest* request,
                       ::xtreemfs::pbrpc::listxattrResponse* response,
                       ::google::protobuf::Closure* done);
  void mkdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::mkdirRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void open(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::openRequest* request,
                       ::xtreemfs::pbrpc::openResponse* response,
                       ::google::protobuf::Closure* done);
  void readdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::readdirRequest* request,
                       ::xtreemfs::pbrpc::DirectoryEntries* response,
                       ::google::protobuf::Closure* done);
  void readlink(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::readlinkRequest* request,
                       ::xtreemfs::pbrpc::readlinkResponse* response,
                       ::google::protobuf::Closure* done);
  void removexattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::removexattrRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void rename(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::renameRequest* request,
                       ::xtreemfs::pbrpc::renameResponse* response,
                       ::google::protobuf::Closure* done);
  void rmdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::rmdirRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void setattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::setattrRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void setxattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::setxattrRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void statvfs(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::statvfsRequest* request,
                       ::xtreemfs::pbrpc::StatVFS* response,
                       ::google::protobuf::Closure* done);
  void symlink(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::symlinkRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void unlink(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::unlinkRequest* request,
                       ::xtreemfs::pbrpc::unlinkResponse* response,
                       ::google::protobuf::Closure* done);
  void access(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::accessRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_checkpoint(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_check_file_exists(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_check_file_existsRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_dump_database(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_dump_restore_databaseRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_get_suitable_osds(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_get_suitable_osdsRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_get_suitable_osdsResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_internal_debug(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::stringMessage* request,
                       ::xtreemfs::pbrpc::stringMessage* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_listdir(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_listdirRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_listdirResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_lsvol(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::Volumes* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_mkvol(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::Volume* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_renew_capability(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::XCap* request,
                       ::xtreemfs::pbrpc::XCap* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_replication_to_master(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_replica_add(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_replica_addRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_replica_list(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_replica_listRequest* request,
                       ::xtreemfs::pbrpc::Replicas* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_replica_remove(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_replica_removeRequest* request,
                       ::xtreemfs::pbrpc::FileCredentials* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_restore_database(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_dump_restore_databaseRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_restore_file(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_restore_fileRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_rmvol(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_rmvolRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_shutdown(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::emptyRequest* request,
                       ::xtreemfs::pbrpc::emptyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_update_file_size(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_update_file_sizeRequest* request,
                       ::xtreemfs::pbrpc::timestampResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_set_replica_update_policy(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_set_replica_update_policyRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_set_replica_update_policyResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_set_read_only_xattr(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_set_read_only_xattrRequest* request,
                       ::xtreemfs::pbrpc::xtreemfs_set_read_only_xattrResponse* response,
                       ::google::protobuf::Closure* done);
  void xtreemfs_get_file_credentials(::google::protobuf::RpcController* controller,
                       const ::xtreemfs::pbrpc::xtreemfs_get_file_credentialsRequest* request,
                       ::xtreemfs::pbrpc::FileCredentials* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MRCService_Stub);
};


// ===================================================================


// ===================================================================

// Stat

// required fixed64 dev = 1;
inline bool Stat::has_dev() const {
  return _has_bit(0);
}
inline void Stat::clear_dev() {
  dev_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 Stat::dev() const {
  return dev_;
}
inline void Stat::set_dev(::google::protobuf::uint64 value) {
  _set_bit(0);
  dev_ = value;
}

// required fixed64 ino = 2;
inline bool Stat::has_ino() const {
  return _has_bit(1);
}
inline void Stat::clear_ino() {
  ino_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 Stat::ino() const {
  return ino_;
}
inline void Stat::set_ino(::google::protobuf::uint64 value) {
  _set_bit(1);
  ino_ = value;
}

// required fixed32 mode = 3;
inline bool Stat::has_mode() const {
  return _has_bit(2);
}
inline void Stat::clear_mode() {
  mode_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 Stat::mode() const {
  return mode_;
}
inline void Stat::set_mode(::google::protobuf::uint32 value) {
  _set_bit(2);
  mode_ = value;
}

// required fixed32 nlink = 4;
inline bool Stat::has_nlink() const {
  return _has_bit(3);
}
inline void Stat::clear_nlink() {
  nlink_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 Stat::nlink() const {
  return nlink_;
}
inline void Stat::set_nlink(::google::protobuf::uint32 value) {
  _set_bit(3);
  nlink_ = value;
}

// required string user_id = 5;
inline bool Stat::has_user_id() const {
  return _has_bit(4);
}
inline void Stat::clear_user_id() {
  if (user_id_ != &_default_user_id_) {
    user_id_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Stat::user_id() const {
  return *user_id_;
}
inline void Stat::set_user_id(const ::std::string& value) {
  _set_bit(4);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void Stat::set_user_id(const char* value) {
  _set_bit(4);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void Stat::set_user_id(const char* value, size_t size) {
  _set_bit(4);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stat::mutable_user_id() {
  _set_bit(4);
  if (user_id_ == &_default_user_id_) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}

// required string group_id = 6;
inline bool Stat::has_group_id() const {
  return _has_bit(5);
}
inline void Stat::clear_group_id() {
  if (group_id_ != &_default_group_id_) {
    group_id_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Stat::group_id() const {
  return *group_id_;
}
inline void Stat::set_group_id(const ::std::string& value) {
  _set_bit(5);
  if (group_id_ == &_default_group_id_) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void Stat::set_group_id(const char* value) {
  _set_bit(5);
  if (group_id_ == &_default_group_id_) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void Stat::set_group_id(const char* value, size_t size) {
  _set_bit(5);
  if (group_id_ == &_default_group_id_) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stat::mutable_group_id() {
  _set_bit(5);
  if (group_id_ == &_default_group_id_) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}

// required fixed64 size = 7;
inline bool Stat::has_size() const {
  return _has_bit(6);
}
inline void Stat::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 Stat::size() const {
  return size_;
}
inline void Stat::set_size(::google::protobuf::uint64 value) {
  _set_bit(6);
  size_ = value;
}

// required fixed64 atime_ns = 8;
inline bool Stat::has_atime_ns() const {
  return _has_bit(7);
}
inline void Stat::clear_atime_ns() {
  atime_ns_ = GOOGLE_ULONGLONG(0);
  _clear_bit(7);
}
inline ::google::protobuf::uint64 Stat::atime_ns() const {
  return atime_ns_;
}
inline void Stat::set_atime_ns(::google::protobuf::uint64 value) {
  _set_bit(7);
  atime_ns_ = value;
}

// required fixed64 mtime_ns = 9;
inline bool Stat::has_mtime_ns() const {
  return _has_bit(8);
}
inline void Stat::clear_mtime_ns() {
  mtime_ns_ = GOOGLE_ULONGLONG(0);
  _clear_bit(8);
}
inline ::google::protobuf::uint64 Stat::mtime_ns() const {
  return mtime_ns_;
}
inline void Stat::set_mtime_ns(::google::protobuf::uint64 value) {
  _set_bit(8);
  mtime_ns_ = value;
}

// required fixed64 ctime_ns = 10;
inline bool Stat::has_ctime_ns() const {
  return _has_bit(9);
}
inline void Stat::clear_ctime_ns() {
  ctime_ns_ = GOOGLE_ULONGLONG(0);
  _clear_bit(9);
}
inline ::google::protobuf::uint64 Stat::ctime_ns() const {
  return ctime_ns_;
}
inline void Stat::set_ctime_ns(::google::protobuf::uint64 value) {
  _set_bit(9);
  ctime_ns_ = value;
}

// required fixed32 blksize = 11;
inline bool Stat::has_blksize() const {
  return _has_bit(10);
}
inline void Stat::clear_blksize() {
  blksize_ = 0u;
  _clear_bit(10);
}
inline ::google::protobuf::uint32 Stat::blksize() const {
  return blksize_;
}
inline void Stat::set_blksize(::google::protobuf::uint32 value) {
  _set_bit(10);
  blksize_ = value;
}

// optional fixed64 etag = 12;
inline bool Stat::has_etag() const {
  return _has_bit(11);
}
inline void Stat::clear_etag() {
  etag_ = GOOGLE_ULONGLONG(0);
  _clear_bit(11);
}
inline ::google::protobuf::uint64 Stat::etag() const {
  return etag_;
}
inline void Stat::set_etag(::google::protobuf::uint64 value) {
  _set_bit(11);
  etag_ = value;
}

// required fixed32 truncate_epoch = 13;
inline bool Stat::has_truncate_epoch() const {
  return _has_bit(12);
}
inline void Stat::clear_truncate_epoch() {
  truncate_epoch_ = 0u;
  _clear_bit(12);
}
inline ::google::protobuf::uint32 Stat::truncate_epoch() const {
  return truncate_epoch_;
}
inline void Stat::set_truncate_epoch(::google::protobuf::uint32 value) {
  _set_bit(12);
  truncate_epoch_ = value;
}

// optional fixed32 attributes = 14;
inline bool Stat::has_attributes() const {
  return _has_bit(13);
}
inline void Stat::clear_attributes() {
  attributes_ = 0u;
  _clear_bit(13);
}
inline ::google::protobuf::uint32 Stat::attributes() const {
  return attributes_;
}
inline void Stat::set_attributes(::google::protobuf::uint32 value) {
  _set_bit(13);
  attributes_ = value;
}

// -------------------------------------------------------------------

// DirectoryEntry

// required string name = 1;
inline bool DirectoryEntry::has_name() const {
  return _has_bit(0);
}
inline void DirectoryEntry::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DirectoryEntry::name() const {
  return *name_;
}
inline void DirectoryEntry::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DirectoryEntry::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DirectoryEntry::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectoryEntry::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional .xtreemfs.pbrpc.Stat stbuf = 2;
inline bool DirectoryEntry::has_stbuf() const {
  return _has_bit(1);
}
inline void DirectoryEntry::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  _clear_bit(1);
}
inline const ::xtreemfs::pbrpc::Stat& DirectoryEntry::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* DirectoryEntry::mutable_stbuf() {
  _set_bit(1);
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}

// -------------------------------------------------------------------

// DirectoryEntries

// repeated .xtreemfs.pbrpc.DirectoryEntry entries = 1;
inline int DirectoryEntries::entries_size() const {
  return entries_.size();
}
inline void DirectoryEntries::clear_entries() {
  entries_.Clear();
}
inline const ::xtreemfs::pbrpc::DirectoryEntry& DirectoryEntries::entries(int index) const {
  return entries_.Get(index);
}
inline ::xtreemfs::pbrpc::DirectoryEntry* DirectoryEntries::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::xtreemfs::pbrpc::DirectoryEntry* DirectoryEntries::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >&
DirectoryEntries::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >*
DirectoryEntries::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// XAttr

// required string name = 1;
inline bool XAttr::has_name() const {
  return _has_bit(0);
}
inline void XAttr::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& XAttr::name() const {
  return *name_;
}
inline void XAttr::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XAttr::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XAttr::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XAttr::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string value = 2;
inline bool XAttr::has_value() const {
  return _has_bit(1);
}
inline void XAttr::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& XAttr::value() const {
  return *value_;
}
inline void XAttr::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void XAttr::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void XAttr::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XAttr::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// Volume

// required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 1;
inline bool Volume::has_access_control_policy() const {
  return _has_bit(0);
}
inline void Volume::clear_access_control_policy() {
  access_control_policy_ = 1;
  _clear_bit(0);
}
inline xtreemfs::pbrpc::AccessControlPolicyType Volume::access_control_policy() const {
  return static_cast< xtreemfs::pbrpc::AccessControlPolicyType >(access_control_policy_);
}
inline void Volume::set_access_control_policy(xtreemfs::pbrpc::AccessControlPolicyType value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::AccessControlPolicyType_IsValid(value));
  _set_bit(0);
  access_control_policy_ = value;
}

// required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 2;
inline bool Volume::has_default_striping_policy() const {
  return _has_bit(1);
}
inline void Volume::clear_default_striping_policy() {
  if (default_striping_policy_ != NULL) default_striping_policy_->::xtreemfs::pbrpc::StripingPolicy::Clear();
  _clear_bit(1);
}
inline const ::xtreemfs::pbrpc::StripingPolicy& Volume::default_striping_policy() const {
  return default_striping_policy_ != NULL ? *default_striping_policy_ : *default_instance_->default_striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* Volume::mutable_default_striping_policy() {
  _set_bit(1);
  if (default_striping_policy_ == NULL) default_striping_policy_ = new ::xtreemfs::pbrpc::StripingPolicy;
  return default_striping_policy_;
}

// required string id = 3;
inline bool Volume::has_id() const {
  return _has_bit(2);
}
inline void Volume::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Volume::id() const {
  return *id_;
}
inline void Volume::set_id(const ::std::string& value) {
  _set_bit(2);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Volume::set_id(const char* value) {
  _set_bit(2);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Volume::set_id(const char* value, size_t size) {
  _set_bit(2);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_id() {
  _set_bit(2);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required fixed32 mode = 4;
inline bool Volume::has_mode() const {
  return _has_bit(3);
}
inline void Volume::clear_mode() {
  mode_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 Volume::mode() const {
  return mode_;
}
inline void Volume::set_mode(::google::protobuf::uint32 value) {
  _set_bit(3);
  mode_ = value;
}

// required string name = 5;
inline bool Volume::has_name() const {
  return _has_bit(4);
}
inline void Volume::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Volume::name() const {
  return *name_;
}
inline void Volume::set_name(const ::std::string& value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Volume::set_name(const char* value) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Volume::set_name(const char* value, size_t size) {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_name() {
  _set_bit(4);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string owner_group_id = 6;
inline bool Volume::has_owner_group_id() const {
  return _has_bit(5);
}
inline void Volume::clear_owner_group_id() {
  if (owner_group_id_ != &_default_owner_group_id_) {
    owner_group_id_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Volume::owner_group_id() const {
  return *owner_group_id_;
}
inline void Volume::set_owner_group_id(const ::std::string& value) {
  _set_bit(5);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void Volume::set_owner_group_id(const char* value) {
  _set_bit(5);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void Volume::set_owner_group_id(const char* value, size_t size) {
  _set_bit(5);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_owner_group_id() {
  _set_bit(5);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  return owner_group_id_;
}

// required string owner_user_id = 7;
inline bool Volume::has_owner_user_id() const {
  return _has_bit(6);
}
inline void Volume::clear_owner_user_id() {
  if (owner_user_id_ != &_default_owner_user_id_) {
    owner_user_id_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& Volume::owner_user_id() const {
  return *owner_user_id_;
}
inline void Volume::set_owner_user_id(const ::std::string& value) {
  _set_bit(6);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void Volume::set_owner_user_id(const char* value) {
  _set_bit(6);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void Volume::set_owner_user_id(const char* value, size_t size) {
  _set_bit(6);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_owner_user_id() {
  _set_bit(6);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  return owner_user_id_;
}

// repeated .xtreemfs.pbrpc.KeyValuePair attrs = 8;
inline int Volume::attrs_size() const {
  return attrs_.size();
}
inline void Volume::clear_attrs() {
  attrs_.Clear();
}
inline const ::xtreemfs::pbrpc::KeyValuePair& Volume::attrs(int index) const {
  return attrs_.Get(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* Volume::mutable_attrs(int index) {
  return attrs_.Mutable(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* Volume::add_attrs() {
  return attrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
Volume::attrs() const {
  return attrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
Volume::mutable_attrs() {
  return &attrs_;
}

// -------------------------------------------------------------------

// Volumes

// repeated .xtreemfs.pbrpc.Volume volumes = 1;
inline int Volumes::volumes_size() const {
  return volumes_.size();
}
inline void Volumes::clear_volumes() {
  volumes_.Clear();
}
inline const ::xtreemfs::pbrpc::Volume& Volumes::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::xtreemfs::pbrpc::Volume* Volumes::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::xtreemfs::pbrpc::Volume* Volumes::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >&
Volumes::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >*
Volumes::mutable_volumes() {
  return &volumes_;
}

// -------------------------------------------------------------------

// StatVFS

// required fixed32 bsize = 1;
inline bool StatVFS::has_bsize() const {
  return _has_bit(0);
}
inline void StatVFS::clear_bsize() {
  bsize_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StatVFS::bsize() const {
  return bsize_;
}
inline void StatVFS::set_bsize(::google::protobuf::uint32 value) {
  _set_bit(0);
  bsize_ = value;
}

// required fixed64 bavail = 2;
inline bool StatVFS::has_bavail() const {
  return _has_bit(1);
}
inline void StatVFS::clear_bavail() {
  bavail_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 StatVFS::bavail() const {
  return bavail_;
}
inline void StatVFS::set_bavail(::google::protobuf::uint64 value) {
  _set_bit(1);
  bavail_ = value;
}

// required fixed64 blocks = 3;
inline bool StatVFS::has_blocks() const {
  return _has_bit(2);
}
inline void StatVFS::clear_blocks() {
  blocks_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 StatVFS::blocks() const {
  return blocks_;
}
inline void StatVFS::set_blocks(::google::protobuf::uint64 value) {
  _set_bit(2);
  blocks_ = value;
}

// required string fsid = 4;
inline bool StatVFS::has_fsid() const {
  return _has_bit(3);
}
inline void StatVFS::clear_fsid() {
  if (fsid_ != &_default_fsid_) {
    fsid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StatVFS::fsid() const {
  return *fsid_;
}
inline void StatVFS::set_fsid(const ::std::string& value) {
  _set_bit(3);
  if (fsid_ == &_default_fsid_) {
    fsid_ = new ::std::string;
  }
  fsid_->assign(value);
}
inline void StatVFS::set_fsid(const char* value) {
  _set_bit(3);
  if (fsid_ == &_default_fsid_) {
    fsid_ = new ::std::string;
  }
  fsid_->assign(value);
}
inline void StatVFS::set_fsid(const char* value, size_t size) {
  _set_bit(3);
  if (fsid_ == &_default_fsid_) {
    fsid_ = new ::std::string;
  }
  fsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_fsid() {
  _set_bit(3);
  if (fsid_ == &_default_fsid_) {
    fsid_ = new ::std::string;
  }
  return fsid_;
}

// required fixed32 namemax = 5;
inline bool StatVFS::has_namemax() const {
  return _has_bit(4);
}
inline void StatVFS::clear_namemax() {
  namemax_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 StatVFS::namemax() const {
  return namemax_;
}
inline void StatVFS::set_namemax(::google::protobuf::uint32 value) {
  _set_bit(4);
  namemax_ = value;
}

// required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 6;
inline bool StatVFS::has_access_control_policy() const {
  return _has_bit(5);
}
inline void StatVFS::clear_access_control_policy() {
  access_control_policy_ = 1;
  _clear_bit(5);
}
inline xtreemfs::pbrpc::AccessControlPolicyType StatVFS::access_control_policy() const {
  return static_cast< xtreemfs::pbrpc::AccessControlPolicyType >(access_control_policy_);
}
inline void StatVFS::set_access_control_policy(xtreemfs::pbrpc::AccessControlPolicyType value) {
  GOOGLE_DCHECK(xtreemfs::pbrpc::AccessControlPolicyType_IsValid(value));
  _set_bit(5);
  access_control_policy_ = value;
}

// required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 7;
inline bool StatVFS::has_default_striping_policy() const {
  return _has_bit(6);
}
inline void StatVFS::clear_default_striping_policy() {
  if (default_striping_policy_ != NULL) default_striping_policy_->::xtreemfs::pbrpc::StripingPolicy::Clear();
  _clear_bit(6);
}
inline const ::xtreemfs::pbrpc::StripingPolicy& StatVFS::default_striping_policy() const {
  return default_striping_policy_ != NULL ? *default_striping_policy_ : *default_instance_->default_striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* StatVFS::mutable_default_striping_policy() {
  _set_bit(6);
  if (default_striping_policy_ == NULL) default_striping_policy_ = new ::xtreemfs::pbrpc::StripingPolicy;
  return default_striping_policy_;
}

// required fixed64 etag = 8;
inline bool StatVFS::has_etag() const {
  return _has_bit(7);
}
inline void StatVFS::clear_etag() {
  etag_ = GOOGLE_ULONGLONG(0);
  _clear_bit(7);
}
inline ::google::protobuf::uint64 StatVFS::etag() const {
  return etag_;
}
inline void StatVFS::set_etag(::google::protobuf::uint64 value) {
  _set_bit(7);
  etag_ = value;
}

// required fixed32 mode = 9;
inline bool StatVFS::has_mode() const {
  return _has_bit(8);
}
inline void StatVFS::clear_mode() {
  mode_ = 0u;
  _clear_bit(8);
}
inline ::google::protobuf::uint32 StatVFS::mode() const {
  return mode_;
}
inline void StatVFS::set_mode(::google::protobuf::uint32 value) {
  _set_bit(8);
  mode_ = value;
}

// required string name = 10;
inline bool StatVFS::has_name() const {
  return _has_bit(9);
}
inline void StatVFS::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& StatVFS::name() const {
  return *name_;
}
inline void StatVFS::set_name(const ::std::string& value) {
  _set_bit(9);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StatVFS::set_name(const char* value) {
  _set_bit(9);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StatVFS::set_name(const char* value, size_t size) {
  _set_bit(9);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_name() {
  _set_bit(9);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string owner_group_id = 11;
inline bool StatVFS::has_owner_group_id() const {
  return _has_bit(10);
}
inline void StatVFS::clear_owner_group_id() {
  if (owner_group_id_ != &_default_owner_group_id_) {
    owner_group_id_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& StatVFS::owner_group_id() const {
  return *owner_group_id_;
}
inline void StatVFS::set_owner_group_id(const ::std::string& value) {
  _set_bit(10);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void StatVFS::set_owner_group_id(const char* value) {
  _set_bit(10);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void StatVFS::set_owner_group_id(const char* value, size_t size) {
  _set_bit(10);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_owner_group_id() {
  _set_bit(10);
  if (owner_group_id_ == &_default_owner_group_id_) {
    owner_group_id_ = new ::std::string;
  }
  return owner_group_id_;
}

// required string owner_user_id = 12;
inline bool StatVFS::has_owner_user_id() const {
  return _has_bit(11);
}
inline void StatVFS::clear_owner_user_id() {
  if (owner_user_id_ != &_default_owner_user_id_) {
    owner_user_id_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& StatVFS::owner_user_id() const {
  return *owner_user_id_;
}
inline void StatVFS::set_owner_user_id(const ::std::string& value) {
  _set_bit(11);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void StatVFS::set_owner_user_id(const char* value) {
  _set_bit(11);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void StatVFS::set_owner_user_id(const char* value, size_t size) {
  _set_bit(11);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_owner_user_id() {
  _set_bit(11);
  if (owner_user_id_ == &_default_owner_user_id_) {
    owner_user_id_ = new ::std::string;
  }
  return owner_user_id_;
}

// -------------------------------------------------------------------

// fsetattrRequest

// required .xtreemfs.pbrpc.Stat stbuf = 1;
inline bool fsetattrRequest::has_stbuf() const {
  return _has_bit(0);
}
inline void fsetattrRequest::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  _clear_bit(0);
}
inline const ::xtreemfs::pbrpc::Stat& fsetattrRequest::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* fsetattrRequest::mutable_stbuf() {
  _set_bit(0);
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}

// required fixed32 to_set = 2;
inline bool fsetattrRequest::has_to_set() const {
  return _has_bit(1);
}
inline void fsetattrRequest::clear_to_set() {
  to_set_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 fsetattrRequest::to_set() const {
  return to_set_;
}
inline void fsetattrRequest::set_to_set(::google::protobuf::uint32 value) {
  _set_bit(1);
  to_set_ = value;
}

// required .xtreemfs.pbrpc.XCap cap = 3;
inline bool fsetattrRequest::has_cap() const {
  return _has_bit(2);
}
inline void fsetattrRequest::clear_cap() {
  if (cap_ != NULL) cap_->::xtreemfs::pbrpc::XCap::Clear();
  _clear_bit(2);
}
inline const ::xtreemfs::pbrpc::XCap& fsetattrRequest::cap() const {
  return cap_ != NULL ? *cap_ : *default_instance_->cap_;
}
inline ::xtreemfs::pbrpc::XCap* fsetattrRequest::mutable_cap() {
  _set_bit(2);
  if (cap_ == NULL) cap_ = new ::xtreemfs::pbrpc::XCap;
  return cap_;
}

// -------------------------------------------------------------------

// getattrRequest

// required string volume_name = 1;
inline bool getattrRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void getattrRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& getattrRequest::volume_name() const {
  return *volume_name_;
}
inline void getattrRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getattrRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getattrRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getattrRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool getattrRequest::has_path() const {
  return _has_bit(1);
}
inline void getattrRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& getattrRequest::path() const {
  return *path_;
}
inline void getattrRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getattrRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getattrRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getattrRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required fixed64 known_etag = 3;
inline bool getattrRequest::has_known_etag() const {
  return _has_bit(2);
}
inline void getattrRequest::clear_known_etag() {
  known_etag_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 getattrRequest::known_etag() const {
  return known_etag_;
}
inline void getattrRequest::set_known_etag(::google::protobuf::uint64 value) {
  _set_bit(2);
  known_etag_ = value;
}

// -------------------------------------------------------------------

// getattrResponse

// optional .xtreemfs.pbrpc.Stat stbuf = 1;
inline bool getattrResponse::has_stbuf() const {
  return _has_bit(0);
}
inline void getattrResponse::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  _clear_bit(0);
}
inline const ::xtreemfs::pbrpc::Stat& getattrResponse::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* getattrResponse::mutable_stbuf() {
  _set_bit(0);
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}

// -------------------------------------------------------------------

// getxattrRequest

// required string volume_name = 1;
inline bool getxattrRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void getxattrRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& getxattrRequest::volume_name() const {
  return *volume_name_;
}
inline void getxattrRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getxattrRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getxattrRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool getxattrRequest::has_path() const {
  return _has_bit(1);
}
inline void getxattrRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& getxattrRequest::path() const {
  return *path_;
}
inline void getxattrRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getxattrRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getxattrRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required string name = 3;
inline bool getxattrRequest::has_name() const {
  return _has_bit(2);
}
inline void getxattrRequest::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& getxattrRequest::name() const {
  return *name_;
}
inline void getxattrRequest::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void getxattrRequest::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void getxattrRequest::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrRequest::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// getxattrResponse

// required string value = 1;
inline bool getxattrResponse::has_value() const {
  return _has_bit(0);
}
inline void getxattrResponse::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& getxattrResponse::value() const {
  return *value_;
}
inline void getxattrResponse::set_value(const ::std::string& value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void getxattrResponse::set_value(const char* value) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void getxattrResponse::set_value(const char* value, size_t size) {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrResponse::mutable_value() {
  _set_bit(0);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// linkRequest

// required string volume_name = 1;
inline bool linkRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void linkRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& linkRequest::volume_name() const {
  return *volume_name_;
}
inline void linkRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void linkRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void linkRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* linkRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string target_path = 2;
inline bool linkRequest::has_target_path() const {
  return _has_bit(1);
}
inline void linkRequest::clear_target_path() {
  if (target_path_ != &_default_target_path_) {
    target_path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& linkRequest::target_path() const {
  return *target_path_;
}
inline void linkRequest::set_target_path(const ::std::string& value) {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void linkRequest::set_target_path(const char* value) {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void linkRequest::set_target_path(const char* value, size_t size) {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* linkRequest::mutable_target_path() {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  return target_path_;
}

// required string link_path = 3;
inline bool linkRequest::has_link_path() const {
  return _has_bit(2);
}
inline void linkRequest::clear_link_path() {
  if (link_path_ != &_default_link_path_) {
    link_path_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& linkRequest::link_path() const {
  return *link_path_;
}
inline void linkRequest::set_link_path(const ::std::string& value) {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void linkRequest::set_link_path(const char* value) {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void linkRequest::set_link_path(const char* value, size_t size) {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* linkRequest::mutable_link_path() {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  return link_path_;
}

// -------------------------------------------------------------------

// listxattrRequest

// required string volume_name = 1;
inline bool listxattrRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void listxattrRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& listxattrRequest::volume_name() const {
  return *volume_name_;
}
inline void listxattrRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void listxattrRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void listxattrRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* listxattrRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool listxattrRequest::has_path() const {
  return _has_bit(1);
}
inline void listxattrRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& listxattrRequest::path() const {
  return *path_;
}
inline void listxattrRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void listxattrRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void listxattrRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* listxattrRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required bool names_only = 3;
inline bool listxattrRequest::has_names_only() const {
  return _has_bit(2);
}
inline void listxattrRequest::clear_names_only() {
  names_only_ = false;
  _clear_bit(2);
}
inline bool listxattrRequest::names_only() const {
  return names_only_;
}
inline void listxattrRequest::set_names_only(bool value) {
  _set_bit(2);
  names_only_ = value;
}

// -------------------------------------------------------------------

// listxattrResponse

// repeated .xtreemfs.pbrpc.XAttr xattrs = 1;
inline int listxattrResponse::xattrs_size() const {
  return xattrs_.size();
}
inline void listxattrResponse::clear_xattrs() {
  xattrs_.Clear();
}
inline const ::xtreemfs::pbrpc::XAttr& listxattrResponse::xattrs(int index) const {
  return xattrs_.Get(index);
}
inline ::xtreemfs::pbrpc::XAttr* listxattrResponse::mutable_xattrs(int index) {
  return xattrs_.Mutable(index);
}
inline ::xtreemfs::pbrpc::XAttr* listxattrResponse::add_xattrs() {
  return xattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >&
listxattrResponse::xattrs() const {
  return xattrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >*
listxattrResponse::mutable_xattrs() {
  return &xattrs_;
}

// -------------------------------------------------------------------

// mkdirRequest

// required string volume_name = 1;
inline bool mkdirRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void mkdirRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& mkdirRequest::volume_name() const {
  return *volume_name_;
}
inline void mkdirRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void mkdirRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void mkdirRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mkdirRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool mkdirRequest::has_path() const {
  return _has_bit(1);
}
inline void mkdirRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& mkdirRequest::path() const {
  return *path_;
}
inline void mkdirRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void mkdirRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void mkdirRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mkdirRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required fixed32 mode = 3;
inline bool mkdirRequest::has_mode() const {
  return _has_bit(2);
}
inline void mkdirRequest::clear_mode() {
  mode_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 mkdirRequest::mode() const {
  return mode_;
}
inline void mkdirRequest::set_mode(::google::protobuf::uint32 value) {
  _set_bit(2);
  mode_ = value;
}

// -------------------------------------------------------------------

// openRequest

// required string volume_name = 1;
inline bool openRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void openRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& openRequest::volume_name() const {
  return *volume_name_;
}
inline void openRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void openRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void openRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* openRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool openRequest::has_path() const {
  return _has_bit(1);
}
inline void openRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& openRequest::path() const {
  return *path_;
}
inline void openRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void openRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void openRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* openRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required fixed32 flags = 3;
inline bool openRequest::has_flags() const {
  return _has_bit(2);
}
inline void openRequest::clear_flags() {
  flags_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 openRequest::flags() const {
  return flags_;
}
inline void openRequest::set_flags(::google::protobuf::uint32 value) {
  _set_bit(2);
  flags_ = value;
}

// required fixed32 mode = 4;
inline bool openRequest::has_mode() const {
  return _has_bit(3);
}
inline void openRequest::clear_mode() {
  mode_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 openRequest::mode() const {
  return mode_;
}
inline void openRequest::set_mode(::google::protobuf::uint32 value) {
  _set_bit(3);
  mode_ = value;
}

// required fixed32 attributes = 5;
inline bool openRequest::has_attributes() const {
  return _has_bit(4);
}
inline void openRequest::clear_attributes() {
  attributes_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 openRequest::attributes() const {
  return attributes_;
}
inline void openRequest::set_attributes(::google::protobuf::uint32 value) {
  _set_bit(4);
  attributes_ = value;
}

// optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 6;
inline bool openRequest::has_coordinates() const {
  return _has_bit(5);
}
inline void openRequest::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  _clear_bit(5);
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& openRequest::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* openRequest::mutable_coordinates() {
  _set_bit(5);
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}

// -------------------------------------------------------------------

// openResponse

// required .xtreemfs.pbrpc.FileCredentials creds = 1;
inline bool openResponse::has_creds() const {
  return _has_bit(0);
}
inline void openResponse::clear_creds() {
  if (creds_ != NULL) creds_->::xtreemfs::pbrpc::FileCredentials::Clear();
  _clear_bit(0);
}
inline const ::xtreemfs::pbrpc::FileCredentials& openResponse::creds() const {
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* openResponse::mutable_creds() {
  _set_bit(0);
  if (creds_ == NULL) creds_ = new ::xtreemfs::pbrpc::FileCredentials;
  return creds_;
}

// required fixed32 timestamp_s = 2;
inline bool openResponse::has_timestamp_s() const {
  return _has_bit(1);
}
inline void openResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 openResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void openResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  _set_bit(1);
  timestamp_s_ = value;
}

// -------------------------------------------------------------------

// readdirRequest

// required string volume_name = 1;
inline bool readdirRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void readdirRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& readdirRequest::volume_name() const {
  return *volume_name_;
}
inline void readdirRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readdirRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readdirRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readdirRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool readdirRequest::has_path() const {
  return _has_bit(1);
}
inline void readdirRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& readdirRequest::path() const {
  return *path_;
}
inline void readdirRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readdirRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readdirRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readdirRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required fixed64 known_etag = 3;
inline bool readdirRequest::has_known_etag() const {
  return _has_bit(2);
}
inline void readdirRequest::clear_known_etag() {
  known_etag_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 readdirRequest::known_etag() const {
  return known_etag_;
}
inline void readdirRequest::set_known_etag(::google::protobuf::uint64 value) {
  _set_bit(2);
  known_etag_ = value;
}

// required fixed32 limit_directory_entries_count = 4;
inline bool readdirRequest::has_limit_directory_entries_count() const {
  return _has_bit(3);
}
inline void readdirRequest::clear_limit_directory_entries_count() {
  limit_directory_entries_count_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 readdirRequest::limit_directory_entries_count() const {
  return limit_directory_entries_count_;
}
inline void readdirRequest::set_limit_directory_entries_count(::google::protobuf::uint32 value) {
  _set_bit(3);
  limit_directory_entries_count_ = value;
}

// required bool names_only = 5;
inline bool readdirRequest::has_names_only() const {
  return _has_bit(4);
}
inline void readdirRequest::clear_names_only() {
  names_only_ = false;
  _clear_bit(4);
}
inline bool readdirRequest::names_only() const {
  return names_only_;
}
inline void readdirRequest::set_names_only(bool value) {
  _set_bit(4);
  names_only_ = value;
}

// required fixed64 seen_directory_entries_count = 6;
inline bool readdirRequest::has_seen_directory_entries_count() const {
  return _has_bit(5);
}
inline void readdirRequest::clear_seen_directory_entries_count() {
  seen_directory_entries_count_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 readdirRequest::seen_directory_entries_count() const {
  return seen_directory_entries_count_;
}
inline void readdirRequest::set_seen_directory_entries_count(::google::protobuf::uint64 value) {
  _set_bit(5);
  seen_directory_entries_count_ = value;
}

// -------------------------------------------------------------------

// readlinkRequest

// required string volume_name = 1;
inline bool readlinkRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void readlinkRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& readlinkRequest::volume_name() const {
  return *volume_name_;
}
inline void readlinkRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readlinkRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readlinkRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readlinkRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool readlinkRequest::has_path() const {
  return _has_bit(1);
}
inline void readlinkRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& readlinkRequest::path() const {
  return *path_;
}
inline void readlinkRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readlinkRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readlinkRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readlinkRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// -------------------------------------------------------------------

// readlinkResponse

// repeated string link_target_path = 1;
inline int readlinkResponse::link_target_path_size() const {
  return link_target_path_.size();
}
inline void readlinkResponse::clear_link_target_path() {
  link_target_path_.Clear();
}
inline const ::std::string& readlinkResponse::link_target_path(int index) const {
  return link_target_path_.Get(index);
}
inline ::std::string* readlinkResponse::mutable_link_target_path(int index) {
  return link_target_path_.Mutable(index);
}
inline void readlinkResponse::set_link_target_path(int index, const ::std::string& value) {
  link_target_path_.Mutable(index)->assign(value);
}
inline void readlinkResponse::set_link_target_path(int index, const char* value) {
  link_target_path_.Mutable(index)->assign(value);
}
inline void readlinkResponse::set_link_target_path(int index, const char* value, size_t size) {
  link_target_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readlinkResponse::add_link_target_path() {
  return link_target_path_.Add();
}
inline void readlinkResponse::add_link_target_path(const ::std::string& value) {
  link_target_path_.Add()->assign(value);
}
inline void readlinkResponse::add_link_target_path(const char* value) {
  link_target_path_.Add()->assign(value);
}
inline void readlinkResponse::add_link_target_path(const char* value, size_t size) {
  link_target_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
readlinkResponse::link_target_path() const {
  return link_target_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
readlinkResponse::mutable_link_target_path() {
  return &link_target_path_;
}

// -------------------------------------------------------------------

// removexattrRequest

// required string volume_name = 1;
inline bool removexattrRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void removexattrRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& removexattrRequest::volume_name() const {
  return *volume_name_;
}
inline void removexattrRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void removexattrRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void removexattrRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* removexattrRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool removexattrRequest::has_path() const {
  return _has_bit(1);
}
inline void removexattrRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& removexattrRequest::path() const {
  return *path_;
}
inline void removexattrRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void removexattrRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void removexattrRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* removexattrRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required string name = 3;
inline bool removexattrRequest::has_name() const {
  return _has_bit(2);
}
inline void removexattrRequest::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& removexattrRequest::name() const {
  return *name_;
}
inline void removexattrRequest::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void removexattrRequest::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void removexattrRequest::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* removexattrRequest::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// -------------------------------------------------------------------

// renameRequest

// required string volume_name = 1;
inline bool renameRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void renameRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& renameRequest::volume_name() const {
  return *volume_name_;
}
inline void renameRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void renameRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void renameRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* renameRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string source_path = 2;
inline bool renameRequest::has_source_path() const {
  return _has_bit(1);
}
inline void renameRequest::clear_source_path() {
  if (source_path_ != &_default_source_path_) {
    source_path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& renameRequest::source_path() const {
  return *source_path_;
}
inline void renameRequest::set_source_path(const ::std::string& value) {
  _set_bit(1);
  if (source_path_ == &_default_source_path_) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(value);
}
inline void renameRequest::set_source_path(const char* value) {
  _set_bit(1);
  if (source_path_ == &_default_source_path_) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(value);
}
inline void renameRequest::set_source_path(const char* value, size_t size) {
  _set_bit(1);
  if (source_path_ == &_default_source_path_) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* renameRequest::mutable_source_path() {
  _set_bit(1);
  if (source_path_ == &_default_source_path_) {
    source_path_ = new ::std::string;
  }
  return source_path_;
}

// required string target_path = 3;
inline bool renameRequest::has_target_path() const {
  return _has_bit(2);
}
inline void renameRequest::clear_target_path() {
  if (target_path_ != &_default_target_path_) {
    target_path_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& renameRequest::target_path() const {
  return *target_path_;
}
inline void renameRequest::set_target_path(const ::std::string& value) {
  _set_bit(2);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void renameRequest::set_target_path(const char* value) {
  _set_bit(2);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void renameRequest::set_target_path(const char* value, size_t size) {
  _set_bit(2);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* renameRequest::mutable_target_path() {
  _set_bit(2);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  return target_path_;
}

// -------------------------------------------------------------------

// renameResponse

// required fixed32 timestamp_s = 1;
inline bool renameResponse::has_timestamp_s() const {
  return _has_bit(0);
}
inline void renameResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 renameResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void renameResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  _set_bit(0);
  timestamp_s_ = value;
}

// optional .xtreemfs.pbrpc.FileCredentials creds = 2;
inline bool renameResponse::has_creds() const {
  return _has_bit(1);
}
inline void renameResponse::clear_creds() {
  if (creds_ != NULL) creds_->::xtreemfs::pbrpc::FileCredentials::Clear();
  _clear_bit(1);
}
inline const ::xtreemfs::pbrpc::FileCredentials& renameResponse::creds() const {
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* renameResponse::mutable_creds() {
  _set_bit(1);
  if (creds_ == NULL) creds_ = new ::xtreemfs::pbrpc::FileCredentials;
  return creds_;
}

// -------------------------------------------------------------------

// rmdirRequest

// required string volume_name = 1;
inline bool rmdirRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void rmdirRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& rmdirRequest::volume_name() const {
  return *volume_name_;
}
inline void rmdirRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void rmdirRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void rmdirRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rmdirRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool rmdirRequest::has_path() const {
  return _has_bit(1);
}
inline void rmdirRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& rmdirRequest::path() const {
  return *path_;
}
inline void rmdirRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void rmdirRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void rmdirRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rmdirRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// -------------------------------------------------------------------

// setattrRequest

// required string volume_name = 1;
inline bool setattrRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void setattrRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& setattrRequest::volume_name() const {
  return *volume_name_;
}
inline void setattrRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setattrRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setattrRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setattrRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool setattrRequest::has_path() const {
  return _has_bit(1);
}
inline void setattrRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& setattrRequest::path() const {
  return *path_;
}
inline void setattrRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setattrRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setattrRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setattrRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required .xtreemfs.pbrpc.Stat stbuf = 3;
inline bool setattrRequest::has_stbuf() const {
  return _has_bit(2);
}
inline void setattrRequest::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  _clear_bit(2);
}
inline const ::xtreemfs::pbrpc::Stat& setattrRequest::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* setattrRequest::mutable_stbuf() {
  _set_bit(2);
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}

// required fixed32 to_set = 4;
inline bool setattrRequest::has_to_set() const {
  return _has_bit(3);
}
inline void setattrRequest::clear_to_set() {
  to_set_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 setattrRequest::to_set() const {
  return to_set_;
}
inline void setattrRequest::set_to_set(::google::protobuf::uint32 value) {
  _set_bit(3);
  to_set_ = value;
}

// -------------------------------------------------------------------

// setxattrRequest

// required string volume_name = 1;
inline bool setxattrRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void setxattrRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& setxattrRequest::volume_name() const {
  return *volume_name_;
}
inline void setxattrRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setxattrRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setxattrRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool setxattrRequest::has_path() const {
  return _has_bit(1);
}
inline void setxattrRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& setxattrRequest::path() const {
  return *path_;
}
inline void setxattrRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setxattrRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setxattrRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required string name = 3;
inline bool setxattrRequest::has_name() const {
  return _has_bit(2);
}
inline void setxattrRequest::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& setxattrRequest::name() const {
  return *name_;
}
inline void setxattrRequest::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void setxattrRequest::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void setxattrRequest::set_name(const char* value, size_t size) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string value = 4;
inline bool setxattrRequest::has_value() const {
  return _has_bit(3);
}
inline void setxattrRequest::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& setxattrRequest::value() const {
  return *value_;
}
inline void setxattrRequest::set_value(const ::std::string& value) {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void setxattrRequest::set_value(const char* value) {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void setxattrRequest::set_value(const char* value, size_t size) {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_value() {
  _set_bit(3);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// required fixed32 flags = 5;
inline bool setxattrRequest::has_flags() const {
  return _has_bit(4);
}
inline void setxattrRequest::clear_flags() {
  flags_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 setxattrRequest::flags() const {
  return flags_;
}
inline void setxattrRequest::set_flags(::google::protobuf::uint32 value) {
  _set_bit(4);
  flags_ = value;
}

// -------------------------------------------------------------------

// statvfsRequest

// required string volume_name = 1;
inline bool statvfsRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void statvfsRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& statvfsRequest::volume_name() const {
  return *volume_name_;
}
inline void statvfsRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void statvfsRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void statvfsRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* statvfsRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required fixed64 known_etag = 5;
inline bool statvfsRequest::has_known_etag() const {
  return _has_bit(1);
}
inline void statvfsRequest::clear_known_etag() {
  known_etag_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 statvfsRequest::known_etag() const {
  return known_etag_;
}
inline void statvfsRequest::set_known_etag(::google::protobuf::uint64 value) {
  _set_bit(1);
  known_etag_ = value;
}

// -------------------------------------------------------------------

// symlinkRequest

// required string volume_name = 1;
inline bool symlinkRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void symlinkRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& symlinkRequest::volume_name() const {
  return *volume_name_;
}
inline void symlinkRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void symlinkRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void symlinkRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* symlinkRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string target_path = 2;
inline bool symlinkRequest::has_target_path() const {
  return _has_bit(1);
}
inline void symlinkRequest::clear_target_path() {
  if (target_path_ != &_default_target_path_) {
    target_path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& symlinkRequest::target_path() const {
  return *target_path_;
}
inline void symlinkRequest::set_target_path(const ::std::string& value) {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void symlinkRequest::set_target_path(const char* value) {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void symlinkRequest::set_target_path(const char* value, size_t size) {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* symlinkRequest::mutable_target_path() {
  _set_bit(1);
  if (target_path_ == &_default_target_path_) {
    target_path_ = new ::std::string;
  }
  return target_path_;
}

// required string link_path = 3;
inline bool symlinkRequest::has_link_path() const {
  return _has_bit(2);
}
inline void symlinkRequest::clear_link_path() {
  if (link_path_ != &_default_link_path_) {
    link_path_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& symlinkRequest::link_path() const {
  return *link_path_;
}
inline void symlinkRequest::set_link_path(const ::std::string& value) {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void symlinkRequest::set_link_path(const char* value) {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void symlinkRequest::set_link_path(const char* value, size_t size) {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* symlinkRequest::mutable_link_path() {
  _set_bit(2);
  if (link_path_ == &_default_link_path_) {
    link_path_ = new ::std::string;
  }
  return link_path_;
}

// -------------------------------------------------------------------

// unlinkRequest

// required string volume_name = 1;
inline bool unlinkRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void unlinkRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& unlinkRequest::volume_name() const {
  return *volume_name_;
}
inline void unlinkRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void unlinkRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void unlinkRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* unlinkRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool unlinkRequest::has_path() const {
  return _has_bit(1);
}
inline void unlinkRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& unlinkRequest::path() const {
  return *path_;
}
inline void unlinkRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void unlinkRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void unlinkRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* unlinkRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// -------------------------------------------------------------------

// unlinkResponse

// required fixed32 timestamp_s = 1;
inline bool unlinkResponse::has_timestamp_s() const {
  return _has_bit(0);
}
inline void unlinkResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 unlinkResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void unlinkResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  _set_bit(0);
  timestamp_s_ = value;
}

// optional .xtreemfs.pbrpc.FileCredentials creds = 2;
inline bool unlinkResponse::has_creds() const {
  return _has_bit(1);
}
inline void unlinkResponse::clear_creds() {
  if (creds_ != NULL) creds_->::xtreemfs::pbrpc::FileCredentials::Clear();
  _clear_bit(1);
}
inline const ::xtreemfs::pbrpc::FileCredentials& unlinkResponse::creds() const {
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* unlinkResponse::mutable_creds() {
  _set_bit(1);
  if (creds_ == NULL) creds_ = new ::xtreemfs::pbrpc::FileCredentials;
  return creds_;
}

// -------------------------------------------------------------------

// accessRequest

// required string volume_name = 1;
inline bool accessRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void accessRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& accessRequest::volume_name() const {
  return *volume_name_;
}
inline void accessRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void accessRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void accessRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accessRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string path = 2;
inline bool accessRequest::has_path() const {
  return _has_bit(1);
}
inline void accessRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& accessRequest::path() const {
  return *path_;
}
inline void accessRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void accessRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void accessRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accessRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// required fixed32 flags = 3;
inline bool accessRequest::has_flags() const {
  return _has_bit(2);
}
inline void accessRequest::clear_flags() {
  flags_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 accessRequest::flags() const {
  return flags_;
}
inline void accessRequest::set_flags(::google::protobuf::uint32 value) {
  _set_bit(2);
  flags_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_check_file_existsRequest

// required string volume_id = 1;
inline bool xtreemfs_check_file_existsRequest::has_volume_id() const {
  return _has_bit(0);
}
inline void xtreemfs_check_file_existsRequest::clear_volume_id() {
  if (volume_id_ != &_default_volume_id_) {
    volume_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_check_file_existsRequest::volume_id() const {
  return *volume_id_;
}
inline void xtreemfs_check_file_existsRequest::set_volume_id(const ::std::string& value) {
  _set_bit(0);
  if (volume_id_ == &_default_volume_id_) {
    volume_id_ = new ::std::string;
  }
  volume_id_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_volume_id(const char* value) {
  _set_bit(0);
  if (volume_id_ == &_default_volume_id_) {
    volume_id_ = new ::std::string;
  }
  volume_id_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_volume_id(const char* value, size_t size) {
  _set_bit(0);
  if (volume_id_ == &_default_volume_id_) {
    volume_id_ = new ::std::string;
  }
  volume_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsRequest::mutable_volume_id() {
  _set_bit(0);
  if (volume_id_ == &_default_volume_id_) {
    volume_id_ = new ::std::string;
  }
  return volume_id_;
}

// repeated string file_ids = 2;
inline int xtreemfs_check_file_existsRequest::file_ids_size() const {
  return file_ids_.size();
}
inline void xtreemfs_check_file_existsRequest::clear_file_ids() {
  file_ids_.Clear();
}
inline const ::std::string& xtreemfs_check_file_existsRequest::file_ids(int index) const {
  return file_ids_.Get(index);
}
inline ::std::string* xtreemfs_check_file_existsRequest::mutable_file_ids(int index) {
  return file_ids_.Mutable(index);
}
inline void xtreemfs_check_file_existsRequest::set_file_ids(int index, const ::std::string& value) {
  file_ids_.Mutable(index)->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_file_ids(int index, const char* value) {
  file_ids_.Mutable(index)->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_file_ids(int index, const char* value, size_t size) {
  file_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsRequest::add_file_ids() {
  return file_ids_.Add();
}
inline void xtreemfs_check_file_existsRequest::add_file_ids(const ::std::string& value) {
  file_ids_.Add()->assign(value);
}
inline void xtreemfs_check_file_existsRequest::add_file_ids(const char* value) {
  file_ids_.Add()->assign(value);
}
inline void xtreemfs_check_file_existsRequest::add_file_ids(const char* value, size_t size) {
  file_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_check_file_existsRequest::file_ids() const {
  return file_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_check_file_existsRequest::mutable_file_ids() {
  return &file_ids_;
}

// required string osd_uuid = 3;
inline bool xtreemfs_check_file_existsRequest::has_osd_uuid() const {
  return _has_bit(2);
}
inline void xtreemfs_check_file_existsRequest::clear_osd_uuid() {
  if (osd_uuid_ != &_default_osd_uuid_) {
    osd_uuid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& xtreemfs_check_file_existsRequest::osd_uuid() const {
  return *osd_uuid_;
}
inline void xtreemfs_check_file_existsRequest::set_osd_uuid(const ::std::string& value) {
  _set_bit(2);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_osd_uuid(const char* value) {
  _set_bit(2);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_osd_uuid(const char* value, size_t size) {
  _set_bit(2);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsRequest::mutable_osd_uuid() {
  _set_bit(2);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}

// -------------------------------------------------------------------

// xtreemfs_dump_restore_databaseRequest

// required string dump_file = 1;
inline bool xtreemfs_dump_restore_databaseRequest::has_dump_file() const {
  return _has_bit(0);
}
inline void xtreemfs_dump_restore_databaseRequest::clear_dump_file() {
  if (dump_file_ != &_default_dump_file_) {
    dump_file_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_dump_restore_databaseRequest::dump_file() const {
  return *dump_file_;
}
inline void xtreemfs_dump_restore_databaseRequest::set_dump_file(const ::std::string& value) {
  _set_bit(0);
  if (dump_file_ == &_default_dump_file_) {
    dump_file_ = new ::std::string;
  }
  dump_file_->assign(value);
}
inline void xtreemfs_dump_restore_databaseRequest::set_dump_file(const char* value) {
  _set_bit(0);
  if (dump_file_ == &_default_dump_file_) {
    dump_file_ = new ::std::string;
  }
  dump_file_->assign(value);
}
inline void xtreemfs_dump_restore_databaseRequest::set_dump_file(const char* value, size_t size) {
  _set_bit(0);
  if (dump_file_ == &_default_dump_file_) {
    dump_file_ = new ::std::string;
  }
  dump_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_dump_restore_databaseRequest::mutable_dump_file() {
  _set_bit(0);
  if (dump_file_ == &_default_dump_file_) {
    dump_file_ = new ::std::string;
  }
  return dump_file_;
}

// -------------------------------------------------------------------

// xtreemfs_get_suitable_osdsRequest

// optional string file_id = 1;
inline bool xtreemfs_get_suitable_osdsRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_get_suitable_osdsRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_get_suitable_osdsRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// optional string path = 3;
inline bool xtreemfs_get_suitable_osdsRequest::has_path() const {
  return _has_bit(1);
}
inline void xtreemfs_get_suitable_osdsRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& xtreemfs_get_suitable_osdsRequest::path() const {
  return *path_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// optional string volume_name = 4;
inline bool xtreemfs_get_suitable_osdsRequest::has_volume_name() const {
  return _has_bit(2);
}
inline void xtreemfs_get_suitable_osdsRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& xtreemfs_get_suitable_osdsRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_volume_name(const ::std::string& value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_volume_name(const char* value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::mutable_volume_name() {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required fixed32 num_osds = 2;
inline bool xtreemfs_get_suitable_osdsRequest::has_num_osds() const {
  return _has_bit(3);
}
inline void xtreemfs_get_suitable_osdsRequest::clear_num_osds() {
  num_osds_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 xtreemfs_get_suitable_osdsRequest::num_osds() const {
  return num_osds_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_num_osds(::google::protobuf::uint32 value) {
  _set_bit(3);
  num_osds_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_get_suitable_osdsResponse

// repeated string osd_uuids = 1;
inline int xtreemfs_get_suitable_osdsResponse::osd_uuids_size() const {
  return osd_uuids_.size();
}
inline void xtreemfs_get_suitable_osdsResponse::clear_osd_uuids() {
  osd_uuids_.Clear();
}
inline const ::std::string& xtreemfs_get_suitable_osdsResponse::osd_uuids(int index) const {
  return osd_uuids_.Get(index);
}
inline ::std::string* xtreemfs_get_suitable_osdsResponse::mutable_osd_uuids(int index) {
  return osd_uuids_.Mutable(index);
}
inline void xtreemfs_get_suitable_osdsResponse::set_osd_uuids(int index, const ::std::string& value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::set_osd_uuids(int index, const char* value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::set_osd_uuids(int index, const char* value, size_t size) {
  osd_uuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsResponse::add_osd_uuids() {
  return osd_uuids_.Add();
}
inline void xtreemfs_get_suitable_osdsResponse::add_osd_uuids(const ::std::string& value) {
  osd_uuids_.Add()->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::add_osd_uuids(const char* value) {
  osd_uuids_.Add()->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::add_osd_uuids(const char* value, size_t size) {
  osd_uuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_get_suitable_osdsResponse::osd_uuids() const {
  return osd_uuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_get_suitable_osdsResponse::mutable_osd_uuids() {
  return &osd_uuids_;
}

// -------------------------------------------------------------------

// xtreemfs_check_file_existsResponse

// required string bitmap = 1;
inline bool xtreemfs_check_file_existsResponse::has_bitmap() const {
  return _has_bit(0);
}
inline void xtreemfs_check_file_existsResponse::clear_bitmap() {
  if (bitmap_ != &_default_bitmap_) {
    bitmap_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_check_file_existsResponse::bitmap() const {
  return *bitmap_;
}
inline void xtreemfs_check_file_existsResponse::set_bitmap(const ::std::string& value) {
  _set_bit(0);
  if (bitmap_ == &_default_bitmap_) {
    bitmap_ = new ::std::string;
  }
  bitmap_->assign(value);
}
inline void xtreemfs_check_file_existsResponse::set_bitmap(const char* value) {
  _set_bit(0);
  if (bitmap_ == &_default_bitmap_) {
    bitmap_ = new ::std::string;
  }
  bitmap_->assign(value);
}
inline void xtreemfs_check_file_existsResponse::set_bitmap(const char* value, size_t size) {
  _set_bit(0);
  if (bitmap_ == &_default_bitmap_) {
    bitmap_ = new ::std::string;
  }
  bitmap_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsResponse::mutable_bitmap() {
  _set_bit(0);
  if (bitmap_ == &_default_bitmap_) {
    bitmap_ = new ::std::string;
  }
  return bitmap_;
}

// -------------------------------------------------------------------

// timestampResponse

// required fixed32 timestamp_s = 1;
inline bool timestampResponse::has_timestamp_s() const {
  return _has_bit(0);
}
inline void timestampResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 timestampResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void timestampResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  _set_bit(0);
  timestamp_s_ = value;
}

// -------------------------------------------------------------------

// stringMessage

// required string a_string = 1;
inline bool stringMessage::has_a_string() const {
  return _has_bit(0);
}
inline void stringMessage::clear_a_string() {
  if (a_string_ != &_default_a_string_) {
    a_string_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& stringMessage::a_string() const {
  return *a_string_;
}
inline void stringMessage::set_a_string(const ::std::string& value) {
  _set_bit(0);
  if (a_string_ == &_default_a_string_) {
    a_string_ = new ::std::string;
  }
  a_string_->assign(value);
}
inline void stringMessage::set_a_string(const char* value) {
  _set_bit(0);
  if (a_string_ == &_default_a_string_) {
    a_string_ = new ::std::string;
  }
  a_string_->assign(value);
}
inline void stringMessage::set_a_string(const char* value, size_t size) {
  _set_bit(0);
  if (a_string_ == &_default_a_string_) {
    a_string_ = new ::std::string;
  }
  a_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stringMessage::mutable_a_string() {
  _set_bit(0);
  if (a_string_ == &_default_a_string_) {
    a_string_ = new ::std::string;
  }
  return a_string_;
}

// -------------------------------------------------------------------

// xtreemfs_listdirRequest

// required string path = 1;
inline bool xtreemfs_listdirRequest::has_path() const {
  return _has_bit(0);
}
inline void xtreemfs_listdirRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_listdirRequest::path() const {
  return *path_;
}
inline void xtreemfs_listdirRequest::set_path(const ::std::string& value) {
  _set_bit(0);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_listdirRequest::set_path(const char* value) {
  _set_bit(0);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_listdirRequest::set_path(const char* value, size_t size) {
  _set_bit(0);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_listdirRequest::mutable_path() {
  _set_bit(0);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// -------------------------------------------------------------------

// xtreemfs_listdirResponse

// repeated string names = 1;
inline int xtreemfs_listdirResponse::names_size() const {
  return names_.size();
}
inline void xtreemfs_listdirResponse::clear_names() {
  names_.Clear();
}
inline const ::std::string& xtreemfs_listdirResponse::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* xtreemfs_listdirResponse::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void xtreemfs_listdirResponse::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void xtreemfs_listdirResponse::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void xtreemfs_listdirResponse::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_listdirResponse::add_names() {
  return names_.Add();
}
inline void xtreemfs_listdirResponse::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void xtreemfs_listdirResponse::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void xtreemfs_listdirResponse::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_listdirResponse::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_listdirResponse::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// xtreemfs_replica_addRequest

// optional string file_id = 1;
inline bool xtreemfs_replica_addRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_replica_addRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_replica_addRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_addRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// optional string path = 3;
inline bool xtreemfs_replica_addRequest::has_path() const {
  return _has_bit(1);
}
inline void xtreemfs_replica_addRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& xtreemfs_replica_addRequest::path() const {
  return *path_;
}
inline void xtreemfs_replica_addRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// optional string volume_name = 4;
inline bool xtreemfs_replica_addRequest::has_volume_name() const {
  return _has_bit(2);
}
inline void xtreemfs_replica_addRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& xtreemfs_replica_addRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_replica_addRequest::set_volume_name(const ::std::string& value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_volume_name(const char* value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addRequest::mutable_volume_name() {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required .xtreemfs.pbrpc.Replica new_replica = 2;
inline bool xtreemfs_replica_addRequest::has_new_replica() const {
  return _has_bit(3);
}
inline void xtreemfs_replica_addRequest::clear_new_replica() {
  if (new_replica_ != NULL) new_replica_->::xtreemfs::pbrpc::Replica::Clear();
  _clear_bit(3);
}
inline const ::xtreemfs::pbrpc::Replica& xtreemfs_replica_addRequest::new_replica() const {
  return new_replica_ != NULL ? *new_replica_ : *default_instance_->new_replica_;
}
inline ::xtreemfs::pbrpc::Replica* xtreemfs_replica_addRequest::mutable_new_replica() {
  _set_bit(3);
  if (new_replica_ == NULL) new_replica_ = new ::xtreemfs::pbrpc::Replica;
  return new_replica_;
}

// -------------------------------------------------------------------

// xtreemfs_replica_listRequest

// optional string file_id = 1;
inline bool xtreemfs_replica_listRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_replica_listRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_replica_listRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_listRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_listRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// optional string path = 2;
inline bool xtreemfs_replica_listRequest::has_path() const {
  return _has_bit(1);
}
inline void xtreemfs_replica_listRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& xtreemfs_replica_listRequest::path() const {
  return *path_;
}
inline void xtreemfs_replica_listRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_listRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// optional string volume_name = 3;
inline bool xtreemfs_replica_listRequest::has_volume_name() const {
  return _has_bit(2);
}
inline void xtreemfs_replica_listRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& xtreemfs_replica_listRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_replica_listRequest::set_volume_name(const ::std::string& value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_volume_name(const char* value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_listRequest::mutable_volume_name() {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// -------------------------------------------------------------------

// xtreemfs_replica_removeRequest

// optional string file_id = 1;
inline bool xtreemfs_replica_removeRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_replica_removeRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_replica_removeRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_removeRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// optional string path = 3;
inline bool xtreemfs_replica_removeRequest::has_path() const {
  return _has_bit(1);
}
inline void xtreemfs_replica_removeRequest::clear_path() {
  if (path_ != &_default_path_) {
    path_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& xtreemfs_replica_removeRequest::path() const {
  return *path_;
}
inline void xtreemfs_replica_removeRequest::set_path(const ::std::string& value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_path(const char* value) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_path(const char* value, size_t size) {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_path() {
  _set_bit(1);
  if (path_ == &_default_path_) {
    path_ = new ::std::string;
  }
  return path_;
}

// optional string volume_name = 4;
inline bool xtreemfs_replica_removeRequest::has_volume_name() const {
  return _has_bit(2);
}
inline void xtreemfs_replica_removeRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& xtreemfs_replica_removeRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_replica_removeRequest::set_volume_name(const ::std::string& value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_volume_name(const char* value) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_volume_name() {
  _set_bit(2);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// required string osd_uuid = 2;
inline bool xtreemfs_replica_removeRequest::has_osd_uuid() const {
  return _has_bit(3);
}
inline void xtreemfs_replica_removeRequest::clear_osd_uuid() {
  if (osd_uuid_ != &_default_osd_uuid_) {
    osd_uuid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& xtreemfs_replica_removeRequest::osd_uuid() const {
  return *osd_uuid_;
}
inline void xtreemfs_replica_removeRequest::set_osd_uuid(const ::std::string& value) {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_osd_uuid(const char* value) {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_osd_uuid(const char* value, size_t size) {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_osd_uuid() {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}

// -------------------------------------------------------------------

// xtreemfs_restore_fileRequest

// required string file_path = 1;
inline bool xtreemfs_restore_fileRequest::has_file_path() const {
  return _has_bit(0);
}
inline void xtreemfs_restore_fileRequest::clear_file_path() {
  if (file_path_ != &_default_file_path_) {
    file_path_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_restore_fileRequest::file_path() const {
  return *file_path_;
}
inline void xtreemfs_restore_fileRequest::set_file_path(const ::std::string& value) {
  _set_bit(0);
  if (file_path_ == &_default_file_path_) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_path(const char* value) {
  _set_bit(0);
  if (file_path_ == &_default_file_path_) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_path(const char* value, size_t size) {
  _set_bit(0);
  if (file_path_ == &_default_file_path_) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_restore_fileRequest::mutable_file_path() {
  _set_bit(0);
  if (file_path_ == &_default_file_path_) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}

// required string file_id = 2;
inline bool xtreemfs_restore_fileRequest::has_file_id() const {
  return _has_bit(1);
}
inline void xtreemfs_restore_fileRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& xtreemfs_restore_fileRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_restore_fileRequest::set_file_id(const ::std::string& value) {
  _set_bit(1);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_id(const char* value) {
  _set_bit(1);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_id(const char* value, size_t size) {
  _set_bit(1);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_restore_fileRequest::mutable_file_id() {
  _set_bit(1);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// required fixed64 file_size = 3;
inline bool xtreemfs_restore_fileRequest::has_file_size() const {
  return _has_bit(2);
}
inline void xtreemfs_restore_fileRequest::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 xtreemfs_restore_fileRequest::file_size() const {
  return file_size_;
}
inline void xtreemfs_restore_fileRequest::set_file_size(::google::protobuf::uint64 value) {
  _set_bit(2);
  file_size_ = value;
}

// required string osd_uuid = 4;
inline bool xtreemfs_restore_fileRequest::has_osd_uuid() const {
  return _has_bit(3);
}
inline void xtreemfs_restore_fileRequest::clear_osd_uuid() {
  if (osd_uuid_ != &_default_osd_uuid_) {
    osd_uuid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& xtreemfs_restore_fileRequest::osd_uuid() const {
  return *osd_uuid_;
}
inline void xtreemfs_restore_fileRequest::set_osd_uuid(const ::std::string& value) {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_osd_uuid(const char* value) {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_osd_uuid(const char* value, size_t size) {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_restore_fileRequest::mutable_osd_uuid() {
  _set_bit(3);
  if (osd_uuid_ == &_default_osd_uuid_) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}

// required fixed32 stripe_size = 5;
inline bool xtreemfs_restore_fileRequest::has_stripe_size() const {
  return _has_bit(4);
}
inline void xtreemfs_restore_fileRequest::clear_stripe_size() {
  stripe_size_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 xtreemfs_restore_fileRequest::stripe_size() const {
  return stripe_size_;
}
inline void xtreemfs_restore_fileRequest::set_stripe_size(::google::protobuf::uint32 value) {
  _set_bit(4);
  stripe_size_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rmvolRequest

// required string volume_name = 1;
inline bool xtreemfs_rmvolRequest::has_volume_name() const {
  return _has_bit(0);
}
inline void xtreemfs_rmvolRequest::clear_volume_name() {
  if (volume_name_ != &_default_volume_name_) {
    volume_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_rmvolRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_rmvolRequest::set_volume_name(const ::std::string& value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_rmvolRequest::set_volume_name(const char* value) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_rmvolRequest::set_volume_name(const char* value, size_t size) {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rmvolRequest::mutable_volume_name() {
  _set_bit(0);
  if (volume_name_ == &_default_volume_name_) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}

// -------------------------------------------------------------------

// xtreemfs_update_file_sizeRequest

// required .xtreemfs.pbrpc.XCap xcap = 1;
inline bool xtreemfs_update_file_sizeRequest::has_xcap() const {
  return _has_bit(0);
}
inline void xtreemfs_update_file_sizeRequest::clear_xcap() {
  if (xcap_ != NULL) xcap_->::xtreemfs::pbrpc::XCap::Clear();
  _clear_bit(0);
}
inline const ::xtreemfs::pbrpc::XCap& xtreemfs_update_file_sizeRequest::xcap() const {
  return xcap_ != NULL ? *xcap_ : *default_instance_->xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_update_file_sizeRequest::mutable_xcap() {
  _set_bit(0);
  if (xcap_ == NULL) xcap_ = new ::xtreemfs::pbrpc::XCap;
  return xcap_;
}

// required .xtreemfs.pbrpc.OSDWriteResponse osd_write_response = 2;
inline bool xtreemfs_update_file_sizeRequest::has_osd_write_response() const {
  return _has_bit(1);
}
inline void xtreemfs_update_file_sizeRequest::clear_osd_write_response() {
  if (osd_write_response_ != NULL) osd_write_response_->::xtreemfs::pbrpc::OSDWriteResponse::Clear();
  _clear_bit(1);
}
inline const ::xtreemfs::pbrpc::OSDWriteResponse& xtreemfs_update_file_sizeRequest::osd_write_response() const {
  return osd_write_response_ != NULL ? *osd_write_response_ : *default_instance_->osd_write_response_;
}
inline ::xtreemfs::pbrpc::OSDWriteResponse* xtreemfs_update_file_sizeRequest::mutable_osd_write_response() {
  _set_bit(1);
  if (osd_write_response_ == NULL) osd_write_response_ = new ::xtreemfs::pbrpc::OSDWriteResponse;
  return osd_write_response_;
}

// optional bool close_file = 3;
inline bool xtreemfs_update_file_sizeRequest::has_close_file() const {
  return _has_bit(2);
}
inline void xtreemfs_update_file_sizeRequest::clear_close_file() {
  close_file_ = false;
  _clear_bit(2);
}
inline bool xtreemfs_update_file_sizeRequest::close_file() const {
  return close_file_;
}
inline void xtreemfs_update_file_sizeRequest::set_close_file(bool value) {
  _set_bit(2);
  close_file_ = value;
}

// optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 4;
inline bool xtreemfs_update_file_sizeRequest::has_coordinates() const {
  return _has_bit(3);
}
inline void xtreemfs_update_file_sizeRequest::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  _clear_bit(3);
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& xtreemfs_update_file_sizeRequest::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_update_file_sizeRequest::mutable_coordinates() {
  _set_bit(3);
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}

// -------------------------------------------------------------------

// xtreemfs_set_replica_update_policyRequest

// required string file_id = 1;
inline bool xtreemfs_set_replica_update_policyRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_set_replica_update_policyRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_set_replica_update_policyRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_set_replica_update_policyRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_replica_update_policyRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// required string update_policy = 2;
inline bool xtreemfs_set_replica_update_policyRequest::has_update_policy() const {
  return _has_bit(1);
}
inline void xtreemfs_set_replica_update_policyRequest::clear_update_policy() {
  if (update_policy_ != &_default_update_policy_) {
    update_policy_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& xtreemfs_set_replica_update_policyRequest::update_policy() const {
  return *update_policy_;
}
inline void xtreemfs_set_replica_update_policyRequest::set_update_policy(const ::std::string& value) {
  _set_bit(1);
  if (update_policy_ == &_default_update_policy_) {
    update_policy_ = new ::std::string;
  }
  update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_update_policy(const char* value) {
  _set_bit(1);
  if (update_policy_ == &_default_update_policy_) {
    update_policy_ = new ::std::string;
  }
  update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_update_policy(const char* value, size_t size) {
  _set_bit(1);
  if (update_policy_ == &_default_update_policy_) {
    update_policy_ = new ::std::string;
  }
  update_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_replica_update_policyRequest::mutable_update_policy() {
  _set_bit(1);
  if (update_policy_ == &_default_update_policy_) {
    update_policy_ = new ::std::string;
  }
  return update_policy_;
}

// -------------------------------------------------------------------

// xtreemfs_set_replica_update_policyResponse

// required string old_update_policy = 1;
inline bool xtreemfs_set_replica_update_policyResponse::has_old_update_policy() const {
  return _has_bit(0);
}
inline void xtreemfs_set_replica_update_policyResponse::clear_old_update_policy() {
  if (old_update_policy_ != &_default_old_update_policy_) {
    old_update_policy_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_set_replica_update_policyResponse::old_update_policy() const {
  return *old_update_policy_;
}
inline void xtreemfs_set_replica_update_policyResponse::set_old_update_policy(const ::std::string& value) {
  _set_bit(0);
  if (old_update_policy_ == &_default_old_update_policy_) {
    old_update_policy_ = new ::std::string;
  }
  old_update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyResponse::set_old_update_policy(const char* value) {
  _set_bit(0);
  if (old_update_policy_ == &_default_old_update_policy_) {
    old_update_policy_ = new ::std::string;
  }
  old_update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyResponse::set_old_update_policy(const char* value, size_t size) {
  _set_bit(0);
  if (old_update_policy_ == &_default_old_update_policy_) {
    old_update_policy_ = new ::std::string;
  }
  old_update_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_replica_update_policyResponse::mutable_old_update_policy() {
  _set_bit(0);
  if (old_update_policy_ == &_default_old_update_policy_) {
    old_update_policy_ = new ::std::string;
  }
  return old_update_policy_;
}

// -------------------------------------------------------------------

// xtreemfs_set_read_only_xattrRequest

// required string file_id = 1;
inline bool xtreemfs_set_read_only_xattrRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_set_read_only_xattrRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_set_read_only_xattrRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_set_read_only_xattrRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_read_only_xattrRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_read_only_xattrRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_read_only_xattrRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}

// required bool value = 2;
inline bool xtreemfs_set_read_only_xattrRequest::has_value() const {
  return _has_bit(1);
}
inline void xtreemfs_set_read_only_xattrRequest::clear_value() {
  value_ = false;
  _clear_bit(1);
}
inline bool xtreemfs_set_read_only_xattrRequest::value() const {
  return value_;
}
inline void xtreemfs_set_read_only_xattrRequest::set_value(bool value) {
  _set_bit(1);
  value_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_set_read_only_xattrResponse

// required bool was_set = 1;
inline bool xtreemfs_set_read_only_xattrResponse::has_was_set() const {
  return _has_bit(0);
}
inline void xtreemfs_set_read_only_xattrResponse::clear_was_set() {
  was_set_ = false;
  _clear_bit(0);
}
inline bool xtreemfs_set_read_only_xattrResponse::was_set() const {
  return was_set_;
}
inline void xtreemfs_set_read_only_xattrResponse::set_was_set(bool value) {
  _set_bit(0);
  was_set_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_get_file_credentialsRequest

// required string file_id = 1;
inline bool xtreemfs_get_file_credentialsRequest::has_file_id() const {
  return _has_bit(0);
}
inline void xtreemfs_get_file_credentialsRequest::clear_file_id() {
  if (file_id_ != &_default_file_id_) {
    file_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& xtreemfs_get_file_credentialsRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_get_file_credentialsRequest::set_file_id(const ::std::string& value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_file_credentialsRequest::set_file_id(const char* value) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_file_credentialsRequest::set_file_id(const char* value, size_t size) {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_file_credentialsRequest::mutable_file_id() {
  _set_bit(0);
  if (file_id_ == &_default_file_id_) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::Setattrs>() {
  return xtreemfs::pbrpc::Setattrs_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::XATTR_FLAGS>() {
  return xtreemfs::pbrpc::XATTR_FLAGS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xtreemfs::pbrpc::ACCESS_FLAGS>() {
  return xtreemfs::pbrpc::ACCESS_FLAGS_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fMRC_2eproto__INCLUDED
