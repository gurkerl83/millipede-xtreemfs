/*  Copyright (c) 2008-2010 Konrad-Zuse-Zentrum fuer Informationstechnik Berlin

This file is part of XtreemFS. XtreemFS is part of XtreemOS, a Linux-based
Grid Operating System, see <http://www.xtreemos.eu> for more details.
The XtreemOS project has been developed with the financial support of the
European Commission's IST program under contract #FP6-033576.

XtreemFS is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 2 of the License, or (at your option)
any later version.

XtreemFS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with XtreemFS. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * AUTHORS: Jan Stender (ZIB), Bj√∂rn Kolbeck (ZIB)
 */
package org.xtreemfs.common;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.xtreemfs.common.config.ServiceConfig;
import org.xtreemfs.common.logging.Logging;
import org.xtreemfs.common.logging.Logging.Category;
import org.xtreemfs.common.util.NetUtils;
import org.xtreemfs.common.uuids.ServiceUUID;
import org.xtreemfs.dir.client.DIRClient;
import org.xtreemfs.foundation.LifeCycleThread;
import org.xtreemfs.foundation.oncrpc.client.RPCResponse;
import org.xtreemfs.interfaces.AddressMapping;
import org.xtreemfs.interfaces.AddressMappingSet;
import org.xtreemfs.interfaces.Constants;
import org.xtreemfs.interfaces.Service;
import org.xtreemfs.interfaces.ServiceDataMap;
import org.xtreemfs.interfaces.ServiceSet;
import org.xtreemfs.interfaces.utils.ONCRPCException;

/**
 * A thread that regularly sends a heartbeat signal with fresh service data to
 * the Directory Service.
 */
public class HeartbeatThread extends LifeCycleThread {

    /**
     * @return the advertisedHostName
     */
    public String getAdvertisedHostName() {
        return advertisedHostName;
    }

    /**
     * An interface that generates service data to be sent to the Directory
     * Service. Each time a heartbeat signal is sent, new service data will be
     * generated by means of invoking <tt>getServiceData()</tt>.
     */
    public interface ServiceDataGenerator {

        public ServiceSet getServiceData();
    }
    private static final long UPDATE_INTERVAL = 60 * 1000; // 60s

    private ServiceUUID uuid;

    private ServiceDataGenerator serviceDataGen;

    private DIRClient client;

    private volatile boolean quit;

    private final ServiceConfig config;

    private final boolean advertiseUDPEndpoints;

    private final String proto;

    private String advertisedHostName;

    public static final String STATIC_ATTR_PREFIX = "static.";

    public static final String STATUS_ATTR = STATIC_ATTR_PREFIX+"status";

    public HeartbeatThread(String name, DIRClient client, ServiceUUID uuid,
            ServiceDataGenerator serviceDataGen, ServiceConfig config, boolean advertiseUDPEndpoints) {

        super(name);

        setPriority(Thread.MAX_PRIORITY);

        this.client = client;
        this.uuid = uuid;
        this.serviceDataGen = serviceDataGen;
        this.config = config;
        this.advertiseUDPEndpoints = advertiseUDPEndpoints;
        if (!config.isUsingSSL()) {
            proto = Constants.ONCRPC_SCHEME;
        } else {
            if (config.isGRIDSSLmode()) {
                proto = Constants.ONCRPCG_SCHEME;
            } else {
                proto = Constants.ONCRPCS_SCHEME;
            }
        }
    }

    public synchronized void shutdown() {
        RPCResponse<String> r = null;
        try {
            if (client.clientIsAlive()) {

                RPCResponse r1 = client.xtreemfs_service_offline(null, uuid.toString());
                r1.get();
                r1.freeBuffers();

            }
        } catch (Exception ex) {
            Logging.logMessage(Logging.LEVEL_WARN, this, "could not deregister service at DIR");
            Logging.logError(Logging.LEVEL_WARN, this, ex);
        } finally {
            try {
                if (r != null) {
                    r.freeBuffers();
                }
            } catch (Throwable thr) {
            }
        }

        this.quit = true;
        this.interrupt();
    }

    public void initialize() throws IOException {

        List<RPCResponse> responses = new LinkedList<RPCResponse>();

        // initially, ...
        try {

            // ... for each UUID, ...
            registerServices();

            // ... register the address mapping for the service

            AddressMappingSet endpoints = new AddressMappingSet();

            // check if hostname or listen.address are set
            if ("".equals(config.getHostName()) && config.getAddress() == null) {

                endpoints = NetUtils.getReachableEndpoints(config.getPort(),
                        proto);

                if (endpoints.size() > 0)
                    advertisedHostName = endpoints.get(0).getAddress();

                if (advertiseUDPEndpoints) {
                    endpoints.addAll(NetUtils.getReachableEndpoints(config.getPort(),
                            Constants.ONCRPCU_SCHEME));
                }

                for (AddressMapping endpoint : endpoints) {
                    endpoint.setUuid(uuid.toString());
                }

            } else {
                // if it is set, we should use that for UUID mapping!
                endpoints = new AddressMappingSet();

                // remove the leading '/' if necessary
                String host = "".equals(config.getHostName()) ? config.getAddress().getHostName() : config.getHostName();
                if (host.startsWith("/")) {
                    host = host.substring(1);
                }

                try {
                    //see if we can resolve the hostname
                    InetAddress ia = InetAddress.getByName(host);
                } catch (Exception ex) {
                    Logging.logMessage(Logging.LEVEL_WARN, this, "WARNING! Could not resolve my " +
                            "hostname (%s) locally! Please make sure that the hostname is set correctly " +
                            "(either on your system or in the service config file). This will lead to " +
                            "problems if clients and other OSDs cannot resolve this service's address!\n", host);
                }

                // add an oncrpc/oncrpcs mapping
                endpoints.add(new AddressMapping(uuid.toString(), 0, proto, host, config.getPort(), "*", 3600,
                        proto + "://" + host + ":" + config.getPort()));

                advertisedHostName = host;

                if (advertiseUDPEndpoints) {
                    endpoints.add(new AddressMapping(uuid.toString(), 0, Constants.ONCRPCU_SCHEME, host,
                            config.getPort(), "*", 3600, Constants.ONCRPCU_SCHEME + "://" + host + ":" + config.getPort()));
                }

            }

            if (Logging.isInfo()) {
                Logging.logMessage(Logging.LEVEL_INFO, Category.net, this,
                        "registering the following address mapping for the service:");
                for (AddressMapping mapping : endpoints) {
                    Logging.logMessage(Logging.LEVEL_INFO, Category.net, this, mapping.toString());
                }
            }

            // fetch the latest address mapping version from the Directory
            // Serivce
            long version = 0;
            RPCResponse<AddressMappingSet> r2 = client.xtreemfs_address_mappings_get(null, uuid.toString());
            try {
                AddressMappingSet ams = r2.get();

                // retrieve the version number from the address mapping
                if (ams.size() > 0) {
                    version = ams.get(0).getVersion();
                }
            } finally {
                responses.add(r2);
            }

            if (endpoints.size() > 0) {
                endpoints.get(0).setVersion(version);
            }

            // register/update the current address mapping
            RPCResponse r3 = client.xtreemfs_address_mappings_set(null, endpoints);
            try {
                r3.get();
            } finally {
                responses.add(r3);
            }
        } catch (InterruptedException ex) {
        } catch (Exception ex) {
            Logging.logMessage(Logging.LEVEL_ERROR, this,
                    "an error occurred while initially contacting the Directory Service: " + ex);
            throw new IOException("cannot initialize service at XtreemFS DIR: " + ex, ex);
        } finally {
            for (RPCResponse resp : responses) {
                resp.freeBuffers();
            }
        }
    }

    public void run() {
        try {

            Map<String, Long> verMap = new HashMap<String, Long>();

            notifyStarted();

            // periodically, ...
            while (!quit) {

                synchronized (this) {


                    try {

                        registerServices();

                    } catch (IOException ex) {
                        Logging.logError(Logging.LEVEL_ERROR, this, ex);
                    } catch (ONCRPCException ex) {
                        Logging.logError(Logging.LEVEL_ERROR, this, ex);
                    } catch (InterruptedException ex) {
                        quit = true;
                        break;
                    }

                    if (quit) {
                        break;
                    }

                }

                try {
                    Thread.sleep(UPDATE_INTERVAL);
                } catch (InterruptedException e) {
                    // ignore
                }
            }

            notifyStopped();
        } catch (Exception ex) {
            notifyCrashed(ex);
        }
    }

    private void registerServices() throws IOException, ONCRPCException, InterruptedException {
        for (Service reg : serviceDataGen.getServiceData()) {

            RPCResponse<ServiceSet> r1 = null;
            RPCResponse<Long> r2 = null;
            try {
                // ... remove old DS entry if necessary
                r1 = client.xtreemfs_service_get_by_uuid(null, reg.getUuid());
                long currentVersion = 0;
                ServiceSet olset = r1.get();
                Map<String,String> staticAttrs = new HashMap();
                if (olset.size() > 0) {
                    currentVersion = olset.get(0).getVersion();
                    final ServiceDataMap data = olset.get(0).getData();
                    for (String key : data.keySet()) {
                        if (key.startsWith(STATIC_ATTR_PREFIX))
                            staticAttrs.put(key,data.get(key));
                    }
                }

                if (!staticAttrs.containsKey(STATUS_ATTR))
                    staticAttrs.put(STATUS_ATTR, Integer.toString(Constants.SERVICE_STATUS_AVAIL));
                
                reg.setVersion(currentVersion);
                final ServiceDataMap data = reg.getData();
                for (Entry<String,String> sAttr : staticAttrs.entrySet()) {
                    data.put(sAttr.getKey(), sAttr.getValue());
                }
                r2 = client.xtreemfs_service_register(null, reg);
                r2.get();

                if (Logging.isDebug()) {
                    Logging.logMessage(Logging.LEVEL_DEBUG, Category.misc, this,
                            "%s successfully updated at Directory Service", uuid);
                }
            } finally {
                if (r1 != null) {
                    r1.freeBuffers();
                }
                if (r2 != null) {
                    r2.freeBuffers();
                }
            }
        }
    }

    public static void waitForDIR(InetSocketAddress dirAddress, int maxWait_s) throws IOException {
        //check if we can connect to DIR and wait if necessary
        final long tStart = System.currentTimeMillis();
        final long maxWait = maxWait_s * 1000;
        int wait = 1;

        do {

            try {
                Socket s = new Socket();
                s.connect(dirAddress, 2000);
                s.close();
                break;
            } catch (UnknownHostException ex) {
                throw new IOException("Initialization failed: " + ex);
            } catch (IOException ex) {
                //wait for next try
                Logging.logMessage(Logging.LEVEL_WARN, null, "cannot connect to DIR (" + ex + "), waiting " + wait + "s");
            } catch (Exception ex) {
                //abort
                throw new IOException("Initialization failed: " + ex);
            }
            long now = System.currentTimeMillis();
            if (now >= tStart + maxWait) {
                throw new IOException("Initialization failed: XtreemFS DIR @ " + dirAddress + " does not respond.");
            }
            try {
                Thread.sleep(wait * 1000);
            } catch (InterruptedException ex) {
                throw new IOException("Initialization failed: " + ex);
            }
            wait += 1;
        } while (true);
        Logging.logMessage(Logging.LEVEL_INFO, null, "XtreemFS DIR @ " + dirAddress + " ok");
    }
}
